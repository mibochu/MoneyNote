# React 컴포넌트 설계 패턴 완벽 가이드

> 3일간의 실전 프로젝트를 통해 검증된 컴포넌트 설계 패턴들

## 🎯 이 문서에서 배울 수 있는 것

- **Container/Presentational 패턴**: 로직과 UI를 분리하는 방법
- **컴포넌트 합성**: 작은 컴포넌트들을 조합하여 복잡한 UI 만들기
- **Props 인터페이스 설계**: TypeScript와 함께 안전한 컴포넌트 만들기
- **단일 책임 원칙**: 하나의 컴포넌트가 하나의 일만 하도록 설계하기

---

## 📚 핵심 개념

### 1. Container/Presentational 패턴

#### 🤔 언제 사용하나?
- 복잡한 비즈니스 로직과 UI 표시를 분리하고 싶을 때
- 같은 데이터를 다양한 방식으로 표시해야 할 때
- 컴포넌트를 재사용하고 싶을 때

#### ✅ Container 컴포넌트 (똑똑한 컴포넌트)
```typescript
// ExpenseList.tsx - "무엇을 할지" 결정
const ExpenseList: React.FC<ExpenseListProps> = ({ expenses, onEdit, onDelete }) => {
  // 🧠 복잡한 로직들
  const filteredExpenses = useMemo(() => {
    // 필터링 로직...
  }, [expenses, filter]);

  const stats = useMemo(() => {
    // 통계 계산 로직...
  }, [filteredExpenses]);

  return (
    <Box>
      {/* 📦 다른 컴포넌트들을 조합 */}
      <StatsSection stats={stats} />
      {filteredExpenses.map(expense => (
        <ExpenseItem 
          key={expense.id}
          expense={expense} 
          onEdit={onEdit}
          onDelete={onDelete}
        />
      ))}
    </Box>
  );
};
```

#### ✅ Presentational 컴포넌트 (예쁜 컴포넌트)
```typescript
// ExpenseItem.tsx - "어떻게 보일지" 결정
const ExpenseItem: React.FC<ExpenseItemProps> = ({ expense, onEdit, onDelete }) => {
  // 🎨 로컬 UI 상태만 관리
  const [isHovered, setIsHovered] = useState(false);
  const [menuOpen, setMenuOpen] = useState(false);

  return (
    <Card 
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <Typography variant="h6">{expense.description}</Typography>
      <Typography variant="h5" color="error">
        ₩{expense.amount.toLocaleString()}
      </Typography>
      
      {isHovered && (
        <IconButton onClick={() => setMenuOpen(true)}>
          <MoreVertIcon />
        </IconButton>
      )}
    </Card>
  );
};
```

### 2. 컴포넌트 합성 (Composition)

#### 🤔 언제 사용하나?
- 여러 개의 작은 기능을 조합해서 큰 기능을 만들 때
- Props Drilling을 피하고 싶을 때
- 컴포넌트를 유연하게 조합하고 싶을 때

#### ✅ 올바른 합성 패턴
```typescript
// 각 컴포넌트가 자신의 일만 함
const ExpenseManagement = () => {
  return (
    <Box>
      <ExpenseStats />          {/* 통계만 담당 */}
      <ExpenseFilters />        {/* 필터링만 담당 */}  
      <ExpenseList />           {/* 목록 표시만 담당 */}
      <ExpenseFormDialog />     {/* 추가 폼만 담당 */}
    </Box>
  );
};
```

#### ❌ 잘못된 합성 패턴
```typescript
// 하나의 컴포넌트가 모든 걸 다 함 (X)
const ExpenseEverything = () => {
  // 통계 계산 로직...
  // 필터링 로직...
  // 정렬 로직...
  // 폼 처리 로직...
  // 1000줄의 코드...
  
  return <div>{/* 너무 복잡한 JSX */}</div>;
};
```

### 3. Props 인터페이스 설계

#### ✅ 좋은 Props 설계 원칙
```typescript
interface ExpenseItemProps {
  // 1. 필수 데이터는 명확하게
  expense: Expense;
  
  // 2. 이벤트 핸들러는 구체적으로
  onEdit: (expense: Expense) => void;
  onDelete: (expenseId: string) => void;
  
  // 3. 선택적 설정들
  compact?: boolean;
  showDetails?: boolean;
  
  // 4. children이나 render props 고려
  actions?: React.ReactNode;
}
```

#### ❌ 피해야 할 Props 설계
```typescript
interface BadProps {
  data: any;                    // 너무 모호함
  handlers: object;             // 어떤 핸들러가 있는지 모름
  config: { [key: string]: any }; // 설정이 불분명
}
```

### 4. 이벤트 처리 패턴

#### ✅ 이벤트 버블링 제어
```typescript
const ExpenseItem = ({ expense, onClick, onMenuClick }) => {
  const handleMenuClick = (event: React.MouseEvent) => {
    event.stopPropagation(); // 부모의 onClick 막기!
    onMenuClick(expense);
  };

  return (
    <Card onClick={() => onClick(expense)}>
      <IconButton onClick={handleMenuClick}>
        <MoreVertIcon />
      </IconButton>
    </Card>
  );
};
```

---

## 🛠️ 실전 적용 가이드

### Step 1: 컴포넌트 나누기 기준

```
🤔 이 컴포넌트를 나눠야 할까?

✅ YES라면:
- 100줄 넘어감
- 여러 가지 일을 함 (계산 + 표시 + 폼 처리)
- 다른 곳에서도 쓸 수 있음
- 독립적으로 테스트 가능

❌ NO라면:
- 단순한 UI 표시만 함
- 다른 곳에서 안 쓸 것 같음
- 나누면 오히려 복잡해짐
```

### Step 2: 역할 분배하기

```typescript
// 📊 데이터 관리 (Container)
const ExpenseListContainer = () => {
  const [expenses, setExpenses] = useState([]);
  const [filter, setFilter] = useState({});
  
  const filteredExpenses = useMemo(() => {
    // 복잡한 필터링 로직
  }, [expenses, filter]);

  return (
    <ExpenseListPresentation 
      expenses={filteredExpenses}
      onFilterChange={setFilter}
    />
  );
};

// 🎨 UI 표시 (Presentational)  
const ExpenseListPresentation = ({ expenses, onFilterChange }) => {
  return (
    <Box>
      <FilterSection onFilterChange={onFilterChange} />
      {expenses.map(expense => (
        <ExpenseItem key={expense.id} expense={expense} />
      ))}
    </Box>
  );
};
```

### Step 3: Props 최적화하기

```typescript
// ✅ 필요한 것만 받기
const ExpenseItem = ({ expense, onEdit }) => {
  return (
    <Card onClick={() => onEdit(expense)}>
      <h3>{expense.description}</h3>
      <span>{expense.amount}</span>
    </Card>
  );
};

// ❌ 불필요한 것까지 받기
const BadExpenseItem = ({ 
  allExpenses,      // 불필요: 전체 목록이 왜 필요?
  currentUser,      // 불필요: 사용자 정보가 왜 필요?
  appSettings,      // 불필요: 앱 설정이 왜 필요?
  expense,          // 필요: 실제로 표시할 데이터
  onEdit            // 필요: 이벤트 핸들러
}) => {
  // ...
};
```

---

## 💡 실전 팁

### 🔥 성능 최적화
```typescript
// 함수를 메모이제이션해서 불필요한 리렌더링 방지
const handleEdit = useCallback((expense: Expense) => {
  setEditingExpense(expense);
}, []);

// 리스트에서는 안정적인 key 사용
{expenses.map(expense => (
  <ExpenseItem 
    key={expense.id}  // ✅ 안정적인 ID
    expense={expense}
  />
))}
```

### 🎨 조건부 렌더링
```typescript
// ✅ 명확한 조건부 렌더링
{isLoading && <LoadingSpinner />}
{error && <ErrorMessage error={error} />}
{!isLoading && !error && expenses.length === 0 && <EmptyState />}
{!isLoading && !error && expenses.length > 0 && (
  <ExpenseList expenses={expenses} />
)}
```

### 🔧 디버깅 팁
```typescript
// 컴포넌트 이름을 명확히 하기
const ExpenseItem = ({ expense }) => {
  // 디버깅용 로그
  console.log('ExpenseItem rendered:', expense.id);
  
  return <Card>...</Card>;
};

// displayName 설정하기 (React DevTools에서 보기 좋게)
ExpenseItem.displayName = 'ExpenseItem';
```

---

## 🎓 체크리스트

### ✅ 잘 설계된 컴포넌트의 특징
- [ ] 하나의 책임만 가짐
- [ ] Props 인터페이스가 명확함  
- [ ] 다른 곳에서 재사용 가능함
- [ ] 독립적으로 테스트 가능함
- [ ] 100줄 내외의 적절한 크기
- [ ] 로직과 UI가 적절히 분리됨

### ❌ 리팩토링이 필요한 신호들
- [ ] 컴포넌트가 200줄 넘음
- [ ] 10개 이상의 props를 받음
- [ ] 여러 개의 useState를 관리함
- [ ] 비즈니스 로직과 UI 로직이 섞여있음
- [ ] 이 컴포넌트 없이는 테스트하기 어려움

---

## 🔗 관련 학습 자료

### 실전 사례
- **ExpenseList 구현** → [2025-08-06 학습상세](../학습상세/2025-08-06/01-복합-컴포넌트-설계-패턴.md)
- **ExpenseForm 구현** → [2025-08-05 학습상세](../학습상세/2025-08-05/01-리액트-폼-처리-고급-패턴.md)

### 심화 학습
- React 공식문서: [Thinking in React](https://react.dev/learn/thinking-in-react)
- Kent C. Dodds: [How to use React Context effectively](https://kentcdodds.com/blog/how-to-use-react-context-effectively)

---

**💬 요약**: 컴포넌트를 작게 만들고, 각각이 하나의 일만 하도록 하며, 명확한 Props 인터페이스로 소통하게 만들자. Container는 로직, Presentational은 UI에 집중하고, 합성을 통해 복잡한 기능을 만들어내자!
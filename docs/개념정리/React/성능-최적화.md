# React 성능 최적화 실전 가이드

> 실제 프로젝트에서 경험한 성능 문제와 해결법들

## 🎯 핵심 성능 최적화 전략

1. **측정 먼저, 최적화는 나중에**
2. **useMemo는 비싼 계산에만**  
3. **useCallback은 자식 props나 의존성에만**
4. **조건부 렌더링으로 DOM 최소화**
5. **페이지네이션으로 대용량 데이터 처리**

---

## 📊 useMemo 활용법

### ✅ 언제 사용하나?
- 복잡한 계산 (배열 필터링, 정렬, reduce)
- 렌더링할 때마다 반복되는 비싼 연산
- 의존성이 자주 바뀌지 않는 계산

```typescript
// ✅ 좋은 useMemo 사용 예시
const ExpenseList = ({ expenses, filter }) => {
  // 복잡한 필터링 로직 - 메모이제이션 필요!
  const filteredExpenses = useMemo(() => {
    console.log('필터링 계산 시작'); // 필요할 때만 실행됨
    
    let result = [...expenses];
    
    if (filter.startDate) {
      result = result.filter(exp => exp.date >= filter.startDate);
    }
    
    if (filter.category) {
      result = result.filter(exp => exp.category === filter.category);
    }
    
    return result;
  }, [expenses, filter]); // expenses나 filter가 바뀔 때만 재계산

  // 통계 계산도 메모이제이션
  const stats = useMemo(() => {
    const total = filteredExpenses.reduce((sum, exp) => sum + exp.amount, 0);
    const count = filteredExpenses.length;
    const average = count > 0 ? total / count : 0;
    
    return { total, count, average };
  }, [filteredExpenses]);

  return <div>{/* UI 렌더링 */}</div>;
};
```

### ❌ 불필요한 useMemo
```typescript
// ❌ 간단한 계산은 메모이제이션 불필요
const SimpleComponent = ({ a, b }) => {
  const sum = useMemo(() => a + b, [a, b]); // 불필요!
  const isPositive = useMemo(() => sum > 0, [sum]); // 불필요!
  
  // 그냥 이렇게 하면 됨
  const sum = a + b;
  const isPositive = sum > 0;
};
```

---

## 🔄 useCallback 활용법

### ✅ 언제 사용하나?
- 자식 컴포넌트에 props로 전달하는 함수
- 다른 훅의 의존성에 사용되는 함수
- 이벤트 핸들러가 자주 재생성되는 경우

```typescript
// ✅ 좋은 useCallback 사용 예시
const ExpenseList = ({ expenses, onExpenseUpdate }) => {
  const [sortBy, setSortBy] = useState('date');
  const [currentPage, setCurrentPage] = useState(1);

  // 자식에게 전달하는 함수 - 메모이제이션 필요!
  const handleSort = useCallback((newSortBy) => {
    setSortBy(newSortBy);
    setCurrentPage(1); // 정렬 변경 시 첫 페이지로
  }, []); // sortBy, currentPage는 setter이므로 의존성 불필요

  // 다른 훅의 의존성으로 사용되는 함수
  const fetchData = useCallback(async () => {
    const data = await api.getExpenses();
    onExpenseUpdate(data);
  }, [onExpenseUpdate]);

  useEffect(() => {
    fetchData(); // fetchData가 useCallback으로 감싸져 있어야 함
  }, [fetchData]);

  return (
    <div>
      {expenses.map(expense => (
        <ExpenseItem 
          key={expense.id}
          expense={expense}
          onSort={handleSort} // 메모이제이션된 함수 전달
        />
      ))}
    </div>
  );
};
```

---

## 🎨 조건부 렌더링 최적화

### ✅ DOM 크기 최소화
```typescript
const ExpenseList = ({ showFilters, isLoading, error, expenses }) => {
  // 로딩 중이면 다른 것들 렌더링하지 않음
  if (isLoading) {
    return <CircularProgress />;
  }

  // 에러가 있으면 에러만 보여줌
  if (error) {
    return <Alert severity="error">{error}</Alert>;
  }

  return (
    <Box>
      {/* 필터는 열려있을 때만 렌더링 */}
      {showFilters && (
        <Paper sx={{ p: 2 }}>
          {/* 복잡한 필터 UI들... */}
        </Paper>
      )}
      
      {/* 데이터가 있을 때만 목록 렌더링 */}
      {expenses.length > 0 ? (
        <ExpenseList expenses={expenses} />
      ) : (
        <EmptyState message="지출 내역이 없습니다" />
      )}
    </Box>
  );
};
```

---

## 📄 페이지네이션으로 성능 개선

### 🤔 언제 필요한가?
- 100개 이상의 아이템을 표시할 때
- 무한 스크롤보다 페이지 단위 탐색이 좋을 때
- 검색/필터링과 함께 사용할 때

```typescript
const ExpenseList = ({ expenses, pageSize = 10 }) => {
  const [currentPage, setCurrentPage] = useState(1);

  // 전체 데이터에서 현재 페이지 분만 계산
  const totalPages = Math.ceil(expenses.length / pageSize);
  const startIndex = (currentPage - 1) * pageSize;
  const currentExpenses = expenses.slice(startIndex, startIndex + pageSize);

  return (
    <Box>
      {/* 10개씩만 DOM에 렌더링! */}
      <Stack spacing={1}>
        {currentExpenses.map(expense => (
          <ExpenseItem key={expense.id} expense={expense} />
        ))}
      </Stack>

      {/* 페이지네이션 UI */}
      {totalPages > 1 && (
        <Pagination 
          count={totalPages}
          page={currentPage}
          onChange={(_, page) => setCurrentPage(page)}
        />
      )}
    </Box>
  );
};
```

---

## 🔍 성능 측정 방법

### React DevTools Profiler 사용하기
```typescript
// 1. React DevTools 설치
// 2. Profiler 탭에서 녹화 시작
// 3. 앱 조작 (필터 변경, 정렬 등)
// 4. 녹화 중지 후 분석

// 성능 측정용 코드도 추가
const ExpenseList = ({ expenses }) => {
  const filteredExpenses = useMemo(() => {
    const start = performance.now();
    const result = expenses.filter(/* 복잡한 로직 */);
    console.log(`필터링 시간: ${performance.now() - start}ms`);
    return result;
  }, [expenses]);
};
```

### Chrome DevTools 활용
```javascript
// Performance 탭에서 성능 분석
// 1. Performance 탭 열기
// 2. 녹화 시작 (빨간 원 버튼)
// 3. 앱에서 느린 작업 수행
// 4. 녹화 중지
// 5. 긴 Task들 찾아서 분석

// 메모리 사용량도 체크
// Memory 탭에서 힙 스냅샷 비교
```

---

## ⚡ 성능 최적화 체크리스트

### 🎯 우선순위별 최적화

**1순위: 가장 효과적**
- [ ] 페이지네이션/무한스크롤 도입
- [ ] 조건부 렌더링으로 불필요한 DOM 제거
- [ ] 이미지 lazy loading

**2순위: 계산이 복잡할 때**
- [ ] useMemo로 비싼 계산 메모이제이션
- [ ] 필터링/정렬 로직 최적화

**3순위: 리렌더링이 많을 때** 
- [ ] useCallback으로 함수 메모이제이션
- [ ] React.memo로 컴포넌트 메모이제이션

### 🚨 과최적화 주의사항

```typescript
// ❌ 이런 건 하지 마세요
const OverOptimized = ({ name, age }) => {
  // 간단한 문자열 조작을 메모이제이션 (불필요!)
  const greeting = useMemo(() => `안녕하세요, ${name}님!`, [name]);
  
  // 간단한 계산을 메모이제이션 (불필요!)
  const isAdult = useMemo(() => age >= 18, [age]);
  
  // 로컬에서만 쓰는 함수를 메모이제이션 (불필요!)
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);

  return <div>{greeting}</div>;
};

// ✅ 이렇게 하세요
const SimpleComponent = ({ name, age }) => {
  const greeting = `안녕하세요, ${name}님!`;
  const isAdult = age >= 18;
  const handleClick = () => console.log('clicked');

  return <div>{greeting}</div>;
};
```

---

## 📊 실제 성능 개선 사례

### Before: 최적화 전 ExpenseList
```
- 1000개 지출 데이터 로딩: 3초
- 필터 변경 시 응답: 1.5초  
- 정렬 변경 시 응답: 1.2초
- 스크롤: 버벅거림
```

### After: 최적화 후 ExpenseList
```
- 1000개 지출 데이터 로딩: 0.5초 (6배 개선!)
- 필터 변경 시 응답: 0.2초 (7.5배 개선!)
- 정렬 변경 시 응답: 0.1초 (12배 개선!)
- 스크롤: 부드러움
```

### 적용한 최적화 기법
1. **페이지네이션**: 1000개 → 10개씩만 렌더링
2. **useMemo**: 필터링/정렬/통계 계산 메모이제이션  
3. **조건부 렌더링**: 필터 UI는 필요할 때만 렌더링
4. **useCallback**: 이벤트 핸들러 메모이제이션

---

## 🔗 관련 자료

- **실전 사례** → [2025-08-06 성능 최적화](../학습상세/2025-08-06/02-React-성능-최적화-실전-적용.md)
- [React 공식문서: Optimizing Performance](https://react.dev/reference/react)
- [Kent C. Dodds: When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)

**💡 핵심**: 측정부터 하고, 정말 필요한 곳에만 최적화를 적용하자!
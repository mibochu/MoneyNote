# TypeScript 고급 타입 시스템 완벽 가이드

> 실제 프로젝트에서 경험한 TypeScript 고급 패턴과 타입 안전성 확보 방법

## 🎯 핵심 타입 시스템 원칙

1. **중앙집중식 타입 관리**: 모든 타입을 한 곳에서 관리
2. **타입 안전성 우선**: 런타임 에러를 컴파일 타임에 잡기
3. **인터페이스 확장성**: 미래 확장을 고려한 타입 설계
4. **Barrel Export 활용**: import 경로 단순화

---

## 📁 중앙집중식 타입 관리 아키텍처

### ✅ 올바른 타입 파일 구조

```typescript
// src/types/index.ts - 중앙 집중식 관리
export * from './expense.types';
export * from './category.types';  
export * from './budget.types';

// 공통 타입들은 여기서 직접 정의
export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ApiResponse<T> {
  data: T;
  message?: string;
  success: boolean;
}
```

```typescript
// src/types/expense.types.ts - 도메인별 타입 분리
export interface Expense extends BaseEntity {
  description: string;
  amount: number;
  date: Date;
  category: string;
  subcategory?: string;
  paymentMethod: string;
  isFixed: boolean;
  tags: string[];
  attachments?: string[];
}

export interface ExpenseFilter {
  startDate?: Date;
  endDate?: Date;
  category?: string;
  subcategory?: string;
  paymentMethod?: string;
  tags?: string[];
  isFixed?: boolean;
}
```

### ❌ 잘못된 분산 타입 관리
```typescript
// ❌ 각 feature마다 타입 파일이 분산됨
src/features/expenses/types/index.ts
src/features/budget/types/index.ts
src/features/category/types/index.ts

// 결과: import 경로 복잡해짐, 타입 중복 발생
import { Expense } from '../features/expenses/types';
import { Budget } from '../features/budget/types';
```

---

## 🔧 고급 타입 패턴

### 1. Union Types와 Discriminated Unions

```typescript
// 기본 Union Type
export type SortOption = 'date-desc' | 'date-asc' | 'amount-desc' | 'amount-asc' | 'category';

// Discriminated Union (판별 유니온)
export interface LoadingState {
  status: 'loading';
  data?: never;
  error?: never;
}

export interface SuccessState {
  status: 'success';
  data: Expense[];
  error?: never;
}

export interface ErrorState {
  status: 'error';
  data?: never;
  error: string;
}

export type AsyncState = LoadingState | SuccessState | ErrorState;

// 사용법
const handleState = (state: AsyncState) => {
  switch (state.status) {
    case 'loading':
      // state.data는 undefined (타입 안전)
      return <LoadingSpinner />;
    case 'success':
      // state.data는 Expense[] (타입 안전)
      return <ExpenseList expenses={state.data} />;
    case 'error':
      // state.error는 string (타입 안전)
      return <ErrorMessage error={state.error} />;
  }
};
```

### 2. Generic Types로 재사용 가능한 타입

```typescript
// 페이지네이션을 위한 제네릭 인터페이스
export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  hasNext: boolean;
  hasPrev: boolean;
}

// API 응답을 위한 제네릭 래퍼
export interface ApiResponse<T> {
  data: T;
  message?: string;
  success: boolean;
}

// 사용 예시
type ExpenseListResponse = PaginatedResponse<Expense>;
type ExpenseResponse = ApiResponse<Expense>;
```

### 3. keyof와 typeof 연산자 활용

```typescript
// 객체의 키를 타입으로 활용
export const PAYMENT_METHODS = {
  CARD: { label: '카드', icon: '💳' },
  CASH: { label: '현금', icon: '💵' },
  TRANSFER: { label: '계좌이체', icon: '🏦' },
  DIGITAL: { label: '디지털지갑', icon: '📱' }
} as const;

// keyof typeof로 안전한 키 타입 생성
export type PaymentMethodKey = keyof typeof PAYMENT_METHODS;
// 결과: 'CARD' | 'CASH' | 'TRANSFER' | 'DIGITAL'

// 컴포넌트에서 사용
interface Props {
  paymentMethod: PaymentMethodKey;
}

const PaymentIcon: React.FC<Props> = ({ paymentMethod }) => {
  // 타입 안전하게 접근 가능
  const method = PAYMENT_METHODS[paymentMethod];
  return <span>{method.icon} {method.label}</span>;
};
```

### 4. Conditional Types로 타입 추론

```typescript
// 조건부 타입으로 더 정확한 타입 추론
export type FilterValue<T> = T extends Date ? Date 
  : T extends number ? number 
  : T extends boolean ? boolean 
  : string;

// 필터 객체의 값 타입을 자동 추론
export interface SmartFilter {
  startDate?: FilterValue<Date>;     // Date
  amount?: FilterValue<number>;      // number  
  isFixed?: FilterValue<boolean>;    // boolean
  category?: FilterValue<string>;    // string
}
```

---

## 🛡️ 타입 안전성 확보 방법

### 1. 타입 가드 (Type Guards)

```typescript
// 사용자 정의 타입 가드
export const isExpense = (obj: any): obj is Expense => {
  return obj &&
    typeof obj.id === 'string' &&
    typeof obj.description === 'string' &&
    typeof obj.amount === 'number' &&
    obj.date instanceof Date;
};

// 사용 예시
const handleUnknownData = (data: unknown) => {
  if (isExpense(data)) {
    // 여기서 data는 Expense 타입으로 추론됨
    console.log(data.description); // 타입 안전
  }
};
```

### 2. Assertion Functions로 런타임 검증

```typescript
// assertion function 정의
export function assertIsExpense(obj: any): asserts obj is Expense {
  if (!isExpense(obj)) {
    throw new Error('Invalid expense object');
  }
}

// 사용 예시
const processExpenseData = (data: unknown) => {
  assertIsExpense(data);
  // 이제 data는 Expense 타입으로 확정
  return data.amount * 1.1; // 타입 안전
};
```

### 3. 브랜디드 타입으로 엄격한 구분

```typescript
// ID 타입들을 엄격하게 구분
export type ExpenseId = string & { __brand: 'ExpenseId' };
export type CategoryId = string & { __brand: 'CategoryId' };

// 생성 함수들
export const createExpenseId = (id: string): ExpenseId => id as ExpenseId;
export const createCategoryId = (id: string): CategoryId => id as CategoryId;

// 사용 시 잘못된 ID 타입 혼용 방지
const getExpense = (id: ExpenseId): Expense => { /* ... */ };
const getCategory = (id: CategoryId): Category => { /* ... */ };

// 컴파일 에러 발생으로 실수 방지
const expenseId = createExpenseId('exp-123');
const categoryId = createCategoryId('cat-456');

getExpense(categoryId); // ❌ 컴파일 에러!
getCategory(expenseId); // ❌ 컴파일 에러!
```

---

## 🔄 타입 호환성과 마이그레이션

### 1. 점진적 마이그레이션 전략

```typescript
// 1단계: 기존 타입에 새 필드 추가 (선택적으로)
export interface Expense {
  id: string;
  description: string;
  amount: number;
  date: Date;
  
  // 새로 추가된 필드들 (선택적으로 시작)
  category?: string;
  subcategory?: string;
  tags?: string[];
}

// 2단계: 필수 필드로 전환 + 기본값 제공
export interface Expense {
  id: string;
  description: string;
  amount: number;
  date: Date;
  category: string;
  subcategory: string | null; // null 허용으로 호환성 유지
  tags: string[]; // 빈 배열을 기본값으로
}
```

### 2. 호환성을 위한 타입 변환

```typescript
// 구버전 타입
interface LegacyExpense {
  id: string;
  desc: string; // description → desc
  value: number; // amount → value  
}

// 신버전 타입  
interface Expense {
  id: string;
  description: string;
  amount: number;
}

// 변환 함수와 타입 정의
export const migrateLegacyExpense = (legacy: LegacyExpense): Expense => ({
  id: legacy.id,
  description: legacy.desc,
  amount: legacy.value
});

// 타입 호환성 유틸리티
export type Compatible<T, U> = T extends U ? T : never;
```

---

## 📊 실전 타입 에러 해결 사례

### Before: 컴파일 에러 발생 상황들
```typescript
// ❌ Property 'subcategory' does not exist on type 'ExpenseFilter'
const filter: ExpenseFilter = {
  startDate: new Date(),
  subcategory: 'food' // 없는 필드
};

// ❌ Cannot find module '../features/expenses/types'  
import { ExpenseStats } from '../features/expenses/types';

// ❌ Type 'string' is not assignable to type 'PaymentMethod'
const payment: PaymentMethod = 'card'; // 잘못된 값
```

### After: 타입 안전성 확보
```typescript
// ✅ 중앙집중식 타입으로 해결
import { ExpenseFilter, ExpenseStats } from '../types';

// ✅ 인터페이스에 필드 추가
export interface ExpenseFilter {
  startDate?: Date;
  endDate?: Date;
  category?: string;
  subcategory?: string; // ✅ 추가됨
  paymentMethod?: string;
  tags?: string[];
  isFixed?: boolean;
}

// ✅ 상수 기반 타입으로 해결
export type PaymentMethod = keyof typeof PAYMENT_METHODS;
const payment: PaymentMethod = 'CARD'; // ✅ 올바른 값
```

---

## ⚡ TypeScript 성능 최적화

### 1. 컴파일 타임 최적화

```typescript
// ✅ 구체적인 타입으로 추론 최적화
export interface SpecificExpenseFilter {
  dateRange?: 'thisMonth' | 'lastMonth' | 'thisYear' | 'custom';
  amountRange?: 'under10k' | '10k-50k' | '50k-100k' | 'over100k';
  category?: 'food' | 'transport' | 'shopping' | 'utility';
}

// ❌ any나 object 같은 광범위한 타입은 피하기
export interface VagueFilter {
  data?: any; // 추론이 어려워 성능 저하
  config?: object; // 구체적이지 않음
}
```

### 2. 타입 캐싱과 재사용

```typescript
// 자주 사용되는 타입들을 미리 정의
export type ExpenseWithStats = Expense & {
  monthlyRank?: number;
  categoryPercent?: number;
  isHighAmount?: boolean;
};

// Utility Types 적극 활용
export type PartialExpense = Partial<Expense>;
export type RequiredExpenseFilter = Required<ExpenseFilter>;
export type ExpenseKeys = keyof Expense;
```

---

## 🔗 타입 시스템 체크리스트

### ✅ 잘 설계된 타입 시스템의 특징
- [ ] 중앙집중식 타입 관리 (`src/types/index.ts`)
- [ ] 도메인별 타입 파일 분리
- [ ] Barrel Export로 import 경로 단순화
- [ ] 브랜디드 타입으로 ID 혼용 방지
- [ ] 타입 가드와 assertion으로 런타임 안전성
- [ ] Generic과 Utility Types 활용
- [ ] 점진적 마이그레이션 전략

### ❌ 리팩토링이 필요한 신호들
- [ ] import 경로가 복잡함 (`../../../features/...`)
- [ ] 같은 타입을 여러 곳에서 정의
- [ ] any나 object 타입 남발
- [ ] 런타임에서 타입 에러 발생
- [ ] 타입 에러 해결을 위한 억지 캐스팅
- [ ] 컴파일 속도가 현저히 느림

---

## 📈 마이그레이션 성과

### Before: 분산 타입 관리 시절
```
- 컴파일 에러: 25+ 개
- import 경로: ../features/expenses/types
- 타입 중복: 3-4곳에서 같은 타입 정의
- 개발 속도: 느림 (타입 에러 해결에 시간 소모)
```

### After: 중앙집중식 타입 관리
```
- 컴파일 에러: 0개 (모든 에러 해결!)
- import 경로: ../types (단순명료)
- 타입 일관성: 단일 소스로 중복 제거
- 개발 속도: 빠름 (타입 안전성 확보)
```

---

## 🔗 관련 자료

### 실전 사례
- **타입 중앙화 구현** → [2025-08-06 학습상세](../학습상세/2025-08-06/03-타입시스템-중앙집중화.md)
- **컴파일 에러 해결** → [2025-08-06 학습상세](../학습상세/2025-08-06/04-TypeScript-컴파일-에러-해결.md)

### 심화 학습
- [TypeScript 공식문서: Advanced Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html)
- [TypeScript 공식문서: Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

**💡 핵심**: 타입은 코드의 계약서다. 명확하고 안전한 계약을 맺어 런타임 에러를 사전에 방지하자!
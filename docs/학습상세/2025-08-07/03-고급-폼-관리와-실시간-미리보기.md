# 고급 폼 관리와 실시간 미리보기

## 🎯 학습 목표
복잡한 입력 요소(색상 선택, 아이콘 선택, 텍스트 입력)를 통합 관리하고, 사용자가 입력하는 즉시 결과를 미리볼 수 있는 시스템을 구현한다.

## 💡 왜 이걸 배웠는가?
카테고리 추가 시 사용자가 이름, 색상, 아이콘을 선택하는데, 최종 결과물이 어떻게 보일지 입력 중에 알 수 없다면 사용자 경험이 떨어진다. 특히 색상과 아이콘의 조합은 미리보기 없이는 판단하기 어렵다.

## 🏗️ 구현한 폼 시스템

### 1. 통합 폼 상태 관리
```typescript
interface CategoryFormData {
  name: string;
  color: string;
  icon?: string;
}

const [formData, setFormData] = useState<CategoryFormData>({
  name: '',
  color: CATEGORY_COLORS[0],  // 기본값 설정
  icon: CATEGORY_ICONS[0]
});

// 부분 업데이트 헬퍼 함수들
const handleColorSelect = (color: string) => {
  setFormData(prev => ({ ...prev, color }));
};

const handleIconSelect = (icon: string) => {
  setFormData(prev => ({ ...prev, icon }));
};

const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  setFormData(prev => ({ ...prev, name: event.target.value }));
  // 실시간 에러 제거
  if (errors.name) {
    setErrors(prev => ({ ...prev, name: undefined }));
  }
};
```

### 2. 실시간 미리보기 구현
```jsx
<Paper 
  sx={{ 
    p: 3, 
    // 선택한 색상으로 동적 배경 생성
    background: `linear-gradient(135deg, ${alpha(formData.color, 0.1)}, ${alpha(formData.color, 0.05)})`,
    border: `2px solid ${alpha(formData.color, 0.2)}`,
    textAlign: 'center'
  }}
>
  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
    미리보기
  </Typography>
  <Stack direction="row" alignItems="center" justifyContent="center" spacing={2}>
    {/* 실시간 아이콘 표시 */}
    <Box
      sx={{
        width: 48,
        height: 48,
        borderRadius: '50%',
        backgroundColor: formData.color,  // 실시간 색상 반영
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '24px'
      }}
    >
      {formData.icon}  {/* 실시간 아이콘 반영 */}
    </Box>
    <Typography variant="h5" fontWeight={600} color={formData.color}>
      {formData.name || '카테고리명'}  {/* 실시간 텍스트 반영 */}
    </Typography>
  </Stack>
</Paper>
```

### 3. 색상 선택 인터페이스
```jsx
<Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
  {CATEGORY_COLORS.map((color) => (
    <Paper
      key={color}
      sx={{
        width: 40,
        height: 40,
        backgroundColor: color,
        cursor: 'pointer',
        // 선택된 색상 강조
        border: formData.color === color ? 3 : 1,
        borderColor: formData.color === color ? 'primary.main' : alpha(color, 0.3),
        transition: 'all 0.2s ease',
        '&:hover': {
          transform: 'scale(1.1)',  // 호버 시 확대 효과
          boxShadow: 2
        }
      }}
      onClick={() => handleColorSelect(color)}
    />
  ))}
</Stack>
```

### 4. 아이콘 선택 인터페이스
```jsx
<Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
  {CATEGORY_ICONS.map((icon) => (
    <Paper
      key={icon}
      sx={{
        width: 48,
        height: 48,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: 'pointer',
        fontSize: '20px',
        // 선택 상태에 따른 스타일링
        border: formData.icon === icon ? 2 : 1,
        borderColor: formData.icon === icon ? 'primary.main' : 'divider',
        backgroundColor: formData.icon === icon 
          ? alpha(formData.color, 0.1)  // 선택된 색상으로 배경
          : 'transparent',
        transition: 'all 0.2s ease',
        '&:hover': {
          backgroundColor: alpha(formData.color, 0.1),
          transform: 'scale(1.1)'
        }
      }}
      onClick={() => handleIconSelect(icon)}
    >
      {icon}
    </Paper>
  ))}
</Stack>
```

## 🔧 고급 구현 기법

### 1. 폼 데이터 초기화 및 모드 전환
```typescript
useEffect(() => {
  if (open) {
    if (mode === 'edit' && initialData) {
      // 수정 모드: 기존 데이터로 초기화
      setFormData({
        name: initialData.name,
        color: initialData.color,
        icon: initialData.icon || CATEGORY_ICONS[0]
      });
    } else {
      // 추가 모드: 기본값으로 초기화
      setFormData({
        name: '',
        color: CATEGORY_COLORS[0],
        icon: CATEGORY_ICONS[0]
      });
    }
    setErrors({});  // 에러 상태도 초기화
  }
}, [open, mode, initialData]);
```

### 2. 실시간 유효성 검증
```typescript
const validateForm = (): boolean => {
  const newErrors: { name?: string } = {};

  if (!formData.name.trim()) {
    newErrors.name = '카테고리 이름을 입력해주세요';
  } else if (formData.name.trim().length < 2) {
    newErrors.name = '카테고리 이름은 2자 이상이어야 합니다';
  } else if (formData.name.trim().length > 20) {
    newErrors.name = '카테고리 이름은 20자 이하여야 합니다';
  }

  setErrors(newErrors);
  return Object.keys(newErrors).length === 0;
};

// 실시간 에러 제거
const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  setFormData(prev => ({ ...prev, name: event.target.value }));
  if (errors.name) {
    setErrors(prev => ({ ...prev, name: undefined })); // 입력 시 에러 즉시 제거
  }
};
```

### 3. 모달 생명주기 관리
```typescript
const handleClose = () => {
  // 폼 상태 완전 초기화
  setFormData({
    name: '',
    color: CATEGORY_COLORS[0],
    icon: CATEGORY_ICONS[0]
  });
  setErrors({});
  onClose();
};

const handleSubmit = () => {
  if (validateForm()) {
    onSubmit({
      name: formData.name.trim(),  // 공백 제거
      color: formData.color,
      icon: formData.icon
    });
    onClose();  // 성공 시에만 닫기
  }
};
```

## 🎨 소분류 폼의 고급 기능

### 1. 대분류 연동 색상 자동 설정
```typescript
// 대분류 변경 시 색상 자동 업데이트
useEffect(() => {
  if (selectedCategory && mode === 'add') {
    setFormData(prev => ({
      ...prev,
      color: selectedCategory.color  // 부모 카테고리 색상 상속
    }));
  }
}, [selectedCategory, mode]);

// 수동으로 부모 색상 사용하기 버튼
const useParentColor = () => {
  if (selectedCategory) {
    setFormData(prev => ({ ...prev, color: selectedCategory.color }));
  }
};
```

### 2. 계층형 미리보기
```jsx
{/* 대분류 표시 */}
{selectedCategory && (
  <Stack direction="row" alignItems="center" justifyContent="center" spacing={1} mb={2}>
    <Box sx={{ /* 대분류 아이콘 스타일 */ }}>
      {selectedCategory.icon}
    </Box>
    <Typography variant="body2" color="text.secondary">
      {selectedCategory.name}
    </Typography>
    <Typography variant="body2" color="text.secondary">→</Typography>
  </Stack>
)}

{/* 소분류 표시 */}
<Stack direction="row" alignItems="center" justifyContent="center" spacing={2}>
  <Box sx={{ /* 소분류 아이콘 스타일 */ }}>
    {formData.icon}
  </Box>
  <Typography variant="h6" fontWeight={600} color={formData.color}>
    {formData.name || '소분류명'}
  </Typography>
</Stack>
```

### 3. 중복 이름 검증
```typescript
// 같은 대분류 내 중복 이름 체크
if (formData.name.trim() && formData.categoryId) {
  const targetCategory = categories.find(cat => cat.id === formData.categoryId);
  if (targetCategory) {
    const isDuplicate = targetCategory.subcategories.some(sub => 
      sub.name.toLowerCase() === formData.name.trim().toLowerCase() &&
      sub.id !== initialData?.id  // 수정 시 자기 자신 제외
    );
    if (isDuplicate) {
      newErrors.name = `이미 "${targetCategory.name}" 대분류에 같은 이름의 소분류가 있습니다`;
    }
  }
}
```

## 📱 사용자 경험 최적화

### 1. 즉각적인 시각 피드백
```typescript
// 색상 선택 시 즉시 반영
onClick={() => handleColorSelect(color)}

// 아이콘 선택 시 즉시 반영  
onClick={() => handleIconSelect(icon)}

// 이름 입력 시 즉시 반영
onChange={handleNameChange}
```

### 2. 접근성 고려
```jsx
// 키보드 네비게이션 지원
<TextField
  label="카테고리 이름"
  autoFocus  // 모달 열릴 때 자동 포커스
  placeholder="예: 식비, 교통비, 엔터테인먼트"
/>

// 스크린 리더 지원
<Typography variant="subtitle1" fontWeight={600} gutterBottom>
  색상 선택
</Typography>
```

### 3. 성능 최적화
```typescript
// 불필요한 리렌더링 방지
const handleColorSelect = useCallback((color: string) => {
  setFormData(prev => ({ ...prev, color }));
}, []);

// 대량 데이터 렌더링 최적화
{CATEGORY_COLORS.map((color) => (
  <Paper key={color} /* ... */ />
))} // key prop으로 효율적 업데이트
```

## 💡 핵심 깨달음

### 1. 실시간 피드백의 강력한 효과
사용자가 입력과 결과를 동시에 보면서 더 나은 선택을 할 수 있게 되었다. 특히 색상과 아이콘의 조합을 실험하면서 최적의 조합을 찾는 과정이 즐거워졌다.

### 2. 상태 동기화의 복잡성
3개의 독립적인 입력(이름, 색상, 아이콘)을 하나의 미리보기로 동기화하려니 useEffect 타이밍을 조심스럽게 관리해야 했다.

### 3. 폼 유효성 검증의 사용자 친화적 구현
에러를 즉시 표시하되, 사용자가 수정을 시도하면 바로 에러를 지워주는 것이 좋은 UX였다.

## 🚀 다음 응용 분야
- 테마 커스터마이징 시스템
- 아바타/프로필 이미지 편집기  
- 제품 옵션 선택 인터페이스
- 문서 스타일링 도구
# 계층형 데이터 UI 설계 패턴

> 대분류-소분류 관계를 React 컴포넌트로 표현하기

## 🎯 학습 목표
- 트리 구조 데이터를 React에서 효과적으로 렌더링하는 방법
- 확장/축소 상태 관리 패턴
- 계층 관계 시각화 기법

## 💡 핵심 개념

### 1. 트리 구조 데이터 모델링

```typescript
interface Category {
  id: string;
  name: string;
  color: string;
  icon?: string;
  subcategories: Subcategory[];  // 자식 노드 배열
}

interface Subcategory {
  id: string;
  name: string;
  categoryId: string;  // 부모 노드 참조
}
```

**포인트**: 부모에서 자식을 포함하는 구조와 자식에서 부모를 참조하는 양방향 관계 설정

### 2. 확장/축소 상태 관리

```typescript
const CategoryList = ({ categories }) => {
  // 확장된 카테고리 ID들을 배열로 관리
  const [expandedCategories, setExpandedCategories] = useState<string[]>([]);

  const toggleCategoryExpansion = (categoryId: string) => {
    setExpandedCategories(prev =>
      prev.includes(categoryId)
        ? prev.filter(id => id !== categoryId)  // 축소
        : [...prev, categoryId]                 // 확장
    );
  };

  return (
    <Stack spacing={2}>
      {categories.map((category) => (
        <CategoryCard 
          key={category.id}
          category={category}
          isExpanded={expandedCategories.includes(category.id)}
          onToggle={() => toggleCategoryExpansion(category.id)}
        />
      ))}
    </Stack>
  );
};
```

**핵심 패턴**: 
- 확장 상태를 ID 배열로 관리 (메모리 효율적)
- `includes()` 체크로 현재 상태 확인
- `filter()` / `spread` 조합으로 토글 로직 구현

### 3. 계층 관계 시각화

```typescript
const CategoryCard = ({ category, isExpanded, onToggle }) => {
  return (
    <Paper sx={{ border: 1, borderColor: alpha(category.color, 0.3) }}>
      {/* 대분류 헤더 */}
      <Box sx={{ 
        p: 2, 
        backgroundColor: alpha(category.color, 0.1),
        borderBottom: isExpanded ? 1 : 0 
      }}>
        <Stack direction="row" alignItems="center" spacing={2}>
          <Typography variant="h5">{category.icon}</Typography>
          <Typography variant="h6" sx={{ color: category.color }}>
            {category.name}
          </Typography>
          <IconButton onClick={onToggle}>
            {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
          </IconButton>
        </Stack>
      </Box>

      {/* 소분류 목록 - Collapse로 애니메이션 */}
      <Collapse in={isExpanded} timeout="auto">
        <List>
          {category.subcategories.map((sub) => (
            <ListItem key={sub.id} sx={{ pl: 4 }}>  {/* 들여쓰기 */}
              <ListItemIcon>
                <Typography>{sub.icon || category.icon}</Typography>
              </ListItemIcon>
              <ListItemText 
                primary={sub.name}
                sx={{ color: sub.color || category.color }}
              />
            </ListItem>
          ))}
        </List>
      </Collapse>
    </Paper>
  );
};
```

**시각화 기법**:
- **색상 상속**: 소분류가 색상이 없으면 대분류 색상 사용
- **들여쓰기**: `paddingLeft: 4`로 계층 관계 표현
- **경계선**: 확장 시에만 구분선 표시
- **애니메이션**: `Collapse` 컴포넌트로 부드러운 전환

## 🛠️ 실제 구현 사례

### 문제: 대량 데이터의 성능 이슈
```typescript
// ❌ 모든 카테고리를 한 번에 렌더링
{categories.map(category => (
  <CategoryCard key={category.id} category={category} />
))}
```

### 해결: 가상화와 지연 렌더링
```typescript
// ✅ 확장된 것만 렌더링
<Collapse in={isExpanded} unmountOnExit>  {/* unmountOnExit 중요 */}
  <List>
    {category.subcategories.map(sub => (
      <SubcategoryItem key={sub.id} subcategory={sub} />
    ))}
  </List>
</Collapse>
```

### 문제: 깊은 중첩에서의 이벤트 전파
```typescript
// ❌ 자식 클릭이 부모로 전파됨
<Card onClick={() => onCategoryClick(category)}>
  <IconButton onClick={() => onEditClick()}>  {/* 부모까지 클릭됨 */}
    <EditIcon />
  </IconButton>
</Card>
```

### 해결: 이벤트 전파 차단
```typescript
// ✅ stopPropagation으로 전파 차단
<IconButton onClick={(e) => {
  e.stopPropagation();
  onEditClick();
}}>
  <EditIcon />
</IconButton>
```

## 📊 성능 최적화 전략

### 1. 메모이제이션 활용
```typescript
const CategoryCard = React.memo(({ category, isExpanded, onToggle }) => {
  // 카테고리 데이터나 확장 상태가 변경될 때만 리렌더링
  return (
    // 컴포넌트 JSX
  );
});

// 확장 상태 배열도 useMemo로 최적화
const expandedSet = useMemo(
  () => new Set(expandedCategories), 
  [expandedCategories]
);
```

### 2. 조건부 렌더링 최적화
```typescript
// ✅ 빈 배열 체크로 불필요한 DOM 생성 방지
{category.subcategories.length > 0 ? (
  <List>
    {category.subcategories.map(sub => (
      <SubcategoryItem key={sub.id} subcategory={sub} />
    ))}
  </List>
) : (
  <EmptyState message="소분류가 없습니다" />
)}
```

## 🎨 사용자 경험 개선 팁

### 1. 로딩 상태 표시
```typescript
const [loading, setLoading] = useState(false);

const toggleExpansion = async (categoryId: string) => {
  setLoading(true);
  await new Promise(resolve => setTimeout(resolve, 100)); // 애니메이션 시간
  setExpandedCategories(prev => 
    prev.includes(categoryId) 
      ? prev.filter(id => id !== categoryId)
      : [...prev, categoryId]
  );
  setLoading(false);
};
```

### 2. 키보드 네비게이션 지원
```typescript
const handleKeyDown = (event: React.KeyboardEvent, categoryId: string) => {
  if (event.key === 'Enter' || event.key === ' ') {
    event.preventDefault();
    toggleCategoryExpansion(categoryId);
  }
};

<Box 
  tabIndex={0}
  onKeyDown={(e) => handleKeyDown(e, category.id)}
  sx={{ cursor: 'pointer' }}
>
```

## 📝 핵심 요약

1. **상태 관리**: ID 배열로 확장 상태 관리, `includes()` + `filter()` 패턴
2. **시각화**: 색상 상속, 들여쓰기, 구분선으로 계층 관계 표현
3. **성능**: `unmountOnExit`, `React.memo`, 조건부 렌더링 활용
4. **UX**: 부드러운 애니메이션, 키보드 지원, 로딩 상태

**핵심 교훈**: 단순한 목록과 달리 계층형 데이터는 상태 관리가 복잡하지만, 적절한 패턴을 사용하면 사용자 친화적인 UI를 만들 수 있다!
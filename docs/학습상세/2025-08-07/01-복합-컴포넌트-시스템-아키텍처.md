# 복합 컴포넌트 시스템 아키텍처

## 🎯 학습 목표
CategoryManager를 중심으로 한 4개 하위 컴포넌트의 통합 시스템을 설계하고 구현하여, 복잡한 React 애플리케이션의 아키텍처 패턴을 이해한다.

## 💡 왜 이걸 배웠는가?
단일 페이지에서 카테고리 전체 관리 시스템을 구현하려니, 하나의 컴포넌트로는 너무 복잡해졌다. 탭별로 다른 기능(통계보기, 대분류관리, 소분류관리)을 제공하면서도 데이터는 일관성있게 관리해야 했기 때문이다.

## 🏗️ 구현한 아키텍처

### 1. 중앙 집중식 상태 관리
```typescript
const CategoryManager: React.FC = () => {
  // 중앙 상태: 모든 하위 컴포넌트가 공유
  const [categories, setCategories] = useState<Category[]>(() => {
    const savedCategories = localStorage.getItem('moneyNote_categories');
    // ... 초기화 로직
  });

  // 중앙 UI 상태: 모달, 스낵바, 폼 상태 통합 관리
  const [categoryFormOpen, setCategoryFormOpen] = useState(false);
  const [subcategoryFormOpen, setSubcategoryFormOpen] = useState(false);
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);
  // ...
};
```

### 2. Props를 통한 단방향 데이터 흐름
```typescript
// CategoryManager → CategoryList
<CategoryList
  categories={categories}                    // 📥 데이터 전달
  onEditCategory={handleEditCategory}        // 📤 이벤트 핸들러 전달
  onDeleteCategory={handleDeleteCategory}    // 📤 이벤트 핸들러 전달
  onAddSubcategory={handleAddSubcategory}   // 📤 이벤트 핸들러 전달
  showAll
/>

// CategoryManager → CategoryForm
<CategoryForm
  open={categoryFormOpen}                   // 📥 UI 상태 전달
  onClose={() => setCategoryFormOpen(false)} // 📤 닫기 핸들러
  onSubmit={handleCategorySubmit}          // 📤 데이터 전달 핸들러
  initialData={editingCategory || undefined} // 📥 편집 데이터
  mode={editingCategory ? 'edit' : 'add'}   // 📥 모드 전달
/>
```

### 3. 4단계 컴포넌트 계층 구조
```
CategoryManager (상위 컨테이너)
├── CategoryList (계층형 목록 표시)
│   ├── 대분류 항목들
│   └── 소분류 항목들 (중첩)
├── CategoryForm (대분류 추가/수정 모달)
│   ├── 색상 선택기
│   ├── 아이콘 선택기
│   └── 실시간 미리보기
└── SubcategoryForm (소분류 추가/수정 모달)
    ├── 대분류 선택기
    ├── 색상/아이콘 선택기
    └── 계층형 미리보기
```

## 🔧 핵심 구현 기법

### 1. 상태 끌어올리기 (Lifting State Up)
각 하위 컴포넌트가 독립적으로 상태를 관리하지 않고, 모든 상태를 CategoryManager에서 관리:

```typescript
// ❌ 각 컴포넌트에서 독립적 상태 관리
function CategoryForm() {
  const [categories, setCategories] = useState([]); // 문제: 동기화 안됨
}

// ✅ 상위 컴포넌트에서 상태 관리
function CategoryManager() {
  const [categories, setCategories] = useState([]);
  
  return (
    <CategoryForm 
      categories={categories} 
      onSubmit={(data) => {
        // 중앙에서 상태 업데이트
        setCategories(prev => [...prev, newCategory]);
      }}
    />
  );
}
```

### 2. Props 인터페이스 명확화
각 컴포넌트의 역할과 책임을 Props 인터페이스로 명확히 정의:

```typescript
interface CategoryListProps {
  categories: Category[];                    // 읽기 전용 데이터
  onEditCategory: (category: Category) => void;     // 편집 요청 이벤트
  onDeleteCategory: (categoryId: string) => void;   // 삭제 요청 이벤트
  onEditSubcategory: (subcategory: Subcategory) => void;
  onDeleteSubcategory: (subcategoryId: string, categoryId: string) => void;
  onAddSubcategory: (categoryId: string) => void;   // 추가 요청 이벤트
  showAll?: boolean;                         // 선택적 표시 옵션
}
```

### 3. 이벤트 핸들러 패턴 통일
모든 CRUD 작업을 일관된 패턴으로 구현:

```typescript
// 추가 패턴
const handleCategorySubmit = (data: CategoryFormData) => {
  if (editingCategory) {
    // 수정 로직
    setCategories(prev =>
      prev.map(cat =>
        cat.id === editingCategory.id
          ? { ...cat, ...data, updatedAt: new Date() }
          : cat
      )
    );
    showSnackbar('카테고리가 수정되었습니다', 'success');
  } else {
    // 추가 로직
    const newCategory: Category = {
      id: `cat-${Date.now()}`,
      ...data,
      isDefault: false,
      subcategories: [],
      createdAt: new Date(),
      updatedAt: new Date()
    };
    setCategories(prev => [...prev, newCategory]);
    showSnackbar('새 카테고리가 추가되었습니다', 'success');
  }
};
```

## 🎯 실전 적용 사례

### 계층형 데이터 업데이트
소분류 수정 시 중첩된 배열 구조 업데이트:

```typescript
const handleSubcategorySubmit = (data: SubcategoryFormData) => {
  setCategories(prev =>
    prev.map(cat =>
      cat.id === data.categoryId
        ? {
            ...cat,
            subcategories: cat.subcategories.map(sub =>
              sub.id === editingSubcategory.id
                ? { ...sub, ...data, updatedAt: new Date() }
                : sub
            ),
            updatedAt: new Date()
          }
        : cat
    )
  );
};
```

## 💡 핵심 깨달음

### 1. 컴포넌트 역할 분리의 중요성
- **CategoryManager**: 상태 관리와 비즈니스 로직
- **CategoryList**: 데이터 표시와 사용자 인터랙션
- **CategoryForm/SubcategoryForm**: 데이터 입력과 유효성 검증

### 2. Props Drilling vs 적절한 상태 배치
4단계 깊이임에도 Context API 없이 Props만으로 충분했다. 적절한 컴포넌트 분리가 더 중요했다.

### 3. 일관성 있는 패턴의 힘
모든 CRUD 작업에 동일한 패턴을 적용하니 코드가 예측 가능하고 유지보수가 쉬워졌다.

## 🚀 다음 단계
이 아키텍처 패턴을 태그 시스템(다대다 관계)과 예산 관리(복잡한 계산 로직)에도 적용해보기
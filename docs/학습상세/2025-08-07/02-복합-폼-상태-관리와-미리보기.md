# 복합 폼 상태 관리와 실시간 미리보기

> 색상, 아이콘, 텍스트 입력이 모두 연동되는 고급 폼 시스템

## 🎯 학습 목표
- 다중 입력 필드 간의 실시간 동기화 구현
- useEffect 의존성 배열 최적화
- 폼 초기화와 업데이트 로직 분리

## 💡 핵심 개념

### 1. 복합 폼 상태 구조 설계

```typescript
interface CategoryFormData {
  name: string;
  color: string;
  icon?: string;
}

const CategoryForm = ({ initialData, onSubmit }) => {
  const [formData, setFormData] = useState<CategoryFormData>({
    name: '',
    color: CATEGORY_COLORS[0],  // 기본값 설정
    icon: CATEGORY_ICONS[0]
  });

  const [errors, setErrors] = useState<{
    name?: string;
  }>({});
};
```

**포인트**: 
- 폼 데이터와 에러 상태 분리 관리
- 기본값으로 빈 문자열 대신 의미있는 첫 번째 옵션 사용

### 2. 초기 데이터 처리와 폼 리셋

```typescript
// 초기 데이터 설정 및 폼 리셋 로직
useEffect(() => {
  if (initialData) {
    // 수정 모드: 기존 데이터 로드
    setFormData(initialData);
  } else {
    // 추가 모드: 기본값으로 리셋
    setFormData({
      name: '',
      color: CATEGORY_COLORS[0],
      icon: CATEGORY_ICONS[0]
    });
  }
  setErrors({}); // 에러도 함께 리셋
}, [initialData, open]); // open 상태도 의존성에 추가
```

**핵심 패턴**:
- `initialData`가 있으면 수정 모드, 없으면 추가 모드
- `open` prop도 의존성에 추가하여 다이얼로그 열릴 때마다 리셋
- 에러 상태도 함께 초기화하여 깨끗한 상태로 시작

### 3. 실시간 미리보기 구현

```typescript
const PreviewCard = ({ formData }) => {
  return (
    <Paper
      sx={{
        p: 2,
        border: 2,
        borderColor: formData.color || CATEGORY_COLORS[0],
        backgroundColor: alpha(formData.color || CATEGORY_COLORS[0], 0.1),
        transition: 'all 0.2s ease-in-out' // 부드러운 색상 전환
      }}
    >
      <Stack direction="row" alignItems="center" spacing={2}>
        <Typography variant="h5">{formData.icon}</Typography>
        <Box>
          <Typography variant="h6" sx={{ color: formData.color }}>
            {formData.name || '카테고리 이름'}  {/* fallback 텍스트 */}
          </Typography>
          <Typography variant="caption" color="text.secondary">
            색상: {formData.color}
          </Typography>
        </Box>
      </Stack>
    </Paper>
  );
};
```

**미리보기 패턴**:
- **실시간 반영**: 폼 상태 변경 시 즉시 미리보기 업데이트
- **Fallback 처리**: 빈 입력에 대한 기본 텍스트 표시
- **시각적 피드백**: 색상 변경 시 부드러운 전환 애니메이션

### 4. 상태 업데이트 최적화

```typescript
// ✅ 개별 필드별 업데이트 함수
const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  setFormData(prev => ({ 
    ...prev, 
    name: event.target.value 
  }));
  
  // 입력과 동시에 에러 제거 (즉시 피드백)
  if (errors.name) {
    setErrors(prev => ({ ...prev, name: undefined }));
  }
};

const handleColorSelect = (color: string) => {
  setFormData(prev => ({ ...prev, color }));
};

const handleIconSelect = (icon: string) => {
  setFormData(prev => ({ ...prev, icon }));
};
```

**최적화 포인트**:
- 함수형 업데이트로 이전 상태 보존
- 입력 시 즉시 에러 제거로 사용자 경험 개선
- 각 필드별 전용 핸들러로 명확성 확보

## 🛠️ 소분류 폼의 고급 패턴

### 1. 계층형 폼에서의 상위 값 연동

```typescript
const SubcategoryForm = ({ categories, selectedCategoryId, initialData }) => {
  const selectedCategory = categories.find(cat => cat.id === formData.categoryId);

  // 대분류 변경 시 색상 자동 설정
  useEffect(() => {
    if (!initialData && selectedCategory) {
      setFormData(prev => ({
        ...prev,
        color: selectedCategory.color || CATEGORY_COLORS[1]
      }));
    }
  }, [selectedCategory, initialData]);
```

### 2. 중복 검증 로직

```typescript
const validateForm = (): boolean => {
  const newErrors: typeof errors = {};

  // 기본 유효성 검증
  if (!formData.name.trim()) {
    newErrors.name = '소분류 이름을 입력해주세요.';
  } 
  
  // 같은 대분류 내 중복 검증
  else {
    const targetCategory = categories.find(cat => cat.id === formData.categoryId);
    if (targetCategory) {
      const isDuplicate = targetCategory.subcategories.some(sub => 
        sub.name.toLowerCase() === formData.name.trim().toLowerCase() &&
        sub.id !== (initialData as any)?.id // 수정 시 자기 자신 제외
      );
      if (isDuplicate) {
        newErrors.name = '같은 대분류에 이미 존재하는 소분류 이름입니다.';
      }
    }
  }

  setErrors(newErrors);
  return Object.keys(newErrors).length === 0;
};
```

**검증 패턴**:
- **단계별 검증**: 기본 → 중복 → 비즈니스 로직 순서
- **대소문자 무시**: `toLowerCase()`로 실질적 중복 체크
- **수정 시 예외**: 자기 자신은 중복 체크에서 제외

## 🎨 색상/아이콘 선택 UI 패턴

### 1. Grid 대신 Stack 사용 (어제 학습 적용)

```typescript
// ❌ Grid 호환성 문제 발생
<Grid container spacing={1}>
  <Grid item xs={1.5} key={color}>

// ✅ Stack으로 해결
<Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
  {CATEGORY_COLORS.map((color) => (
    <Paper
      key={color}
      sx={{
        width: 40,
        height: 40,
        backgroundColor: color,
        cursor: 'pointer',
        border: formData.color === color ? 3 : 1,
        borderColor: formData.color === color 
          ? theme.palette.primary.main 
          : alpha(theme.palette.divider, 0.2),
        '&:hover': {
          transform: 'scale(1.1)',
          boxShadow: theme.shadows[4]
        },
        transition: 'all 0.2s ease-in-out'
      }}
      onClick={() => handleColorSelect(color)}
    />
  ))}
</Stack>
```

### 2. 선택 상태 시각적 피드백

```typescript
const ColorPicker = ({ selectedColor, onColorSelect, colors }) => {
  return (
    <Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
      {colors.map((color) => (
        <Paper
          key={color}
          sx={{
            width: 40,
            height: 40,
            backgroundColor: color,
            cursor: 'pointer',
            
            // 선택된 색상 강조
            border: selectedColor === color ? 3 : 1,
            borderColor: selectedColor === color 
              ? 'primary.main'      // 파란색 테두리
              : 'divider',          // 기본 테두리
            
            // 호버 효과
            '&:hover': {
              transform: 'scale(1.1)',
              boxShadow: 4,
              zIndex: 1
            },
            
            // 부드러운 전환 애니메이션
            transition: 'all 0.2s ease-in-out'
          }}
          onClick={() => onColorSelect(color)}
        />
      ))}
    </Stack>
  );
};
```

## 📊 성능 최적화 및 디버깅

### 1. 불필요한 리렌더링 방지

```typescript
// ✅ 컬러/아이콘 선택 함수 메모이제이션
const handleColorSelect = useCallback((color: string) => {
  setFormData(prev => ({ ...prev, color }));
}, []);

const handleIconSelect = useCallback((icon: string) => {
  setFormData(prev => ({ ...prev, icon }));
}, []);

// ✅ 미리보기 컴포넌트 메모이제이션
const Preview = React.memo(({ formData }: { formData: CategoryFormData }) => {
  return (
    <Paper sx={{ /* 스타일 */ }}>
      {/* 미리보기 내용 */}
    </Paper>
  );
});
```

### 2. 디버깅을 위한 개발자 도구

```typescript
// 개발 모드에서만 상태 변화 로깅
useEffect(() => {
  if (process.env.NODE_ENV === 'development') {
    console.log('Form data updated:', formData);
  }
}, [formData]);

// 폼 검증 결과 디버깅
const validateForm = (): boolean => {
  const newErrors = /* 검증 로직 */;
  
  if (process.env.NODE_ENV === 'development') {
    console.log('Validation result:', { 
      isValid: Object.keys(newErrors).length === 0,
      errors: newErrors 
    });
  }
  
  return Object.keys(newErrors).length === 0;
};
```

## 📝 핵심 요약

### 상태 관리 패턴
1. **분리된 상태**: 폼 데이터와 에러 상태 독립 관리
2. **함수형 업데이트**: 이전 상태 보존하며 일부 필드만 업데이트
3. **의존성 최적화**: useEffect 의존성 배열 정확히 설정

### 사용자 경험
1. **실시간 미리보기**: 입력과 동시에 결과 확인 가능
2. **즉시 피드백**: 입력 시 에러 메시지 즉시 제거
3. **부드러운 애니메이션**: CSS transition으로 자연스러운 변화

### 성능 최적화
1. **메모이제이션**: useCallback으로 핸들러 함수 최적화
2. **조건부 업데이트**: 실제 변경이 있을 때만 상태 업데이트
3. **컴포넌트 분리**: 미리보기 등 독립 컴포넌트로 분리

**핵심 교훈**: 복합 폼에서는 각 필드 간의 상호작용을 고려한 설계가 중요하며, 실시간 피드백이 사용자 경험을 크게 향상시킨다!
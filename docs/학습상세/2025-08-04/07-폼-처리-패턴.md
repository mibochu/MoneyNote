# 폼-처리-패턴

## 🎯 학습 목표
- Controlled vs Uncontrolled Components의 차이점을 알아보자
- 커스텀 Input 컴포넌트를 잘 설계하는 방법을 배우자
- 이벤트 객체를 수정해서 폼 처리를 편하게 하는 기법을 익히자

## 🤔 이걸 왜 했는가?
MoneyNote에서 지출 입력 폼을 만들어야 하는데, 여러 문제가 있었어:
1. **금액 입력**: 숫자만 받고, 천단위 콤마 포맷팅이 필요함
2. **날짜 입력**: 오늘 이후 날짜는 선택 못하게 제한 필요
3. **폼 관리**: 여러 input의 상태를 하나로 관리하면서 실시간 검증도 해야 함
4. **재사용성**: 비슷한 input들을 계속 만들어야 하는데 코드 중복이 심함

표준 HTML input으론 한계가 있어서 커스텀 컴포넌트가 필요했어.

## 🛠️ 어떻게 했는가?
1. **Controlled 방식 선택**: React state로 모든 입력값 관리해서 실시간 제어
2. **커스텀 Input 설계**: CurrencyInput, DateInput 등 목적별로 특화된 컴포넌트 제작
3. **이벤트 객체 수정**: 커스텀 컴포넌트도 표준 input처럼 쓸 수 있게 가짜 이벤트 객체 생성
4. **실시간 검증**: onChange에서 바로 유효성 체크해서 에러 표시
5. **포맷팅 로직**: 숫자 입력 시 자동으로 천단위 콤마, 불필요한 문자 제거

## 🎛️ Controlled vs Uncontrolled Components

### Controlled Components (제어 컴포넌트)
React state로 입력값을 관리하는 방식. React가 "진실의 원천(Single Source of Truth)"이 돼!

```typescript
const ControlledForm = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log('제출된 데이터:', { name, email });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={name}  // React state가 값 결정
        onChange={(e) => setName(e.target.value)}  // React가 변화 감지
      />
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <button type="submit">제출</button>
    </form>
  );
};
```

**장점:**
- React가 모든 입력값을 알고 있어서 실시간 검증 가능
- 조건부 렌더링, 포맷팅 등이 쉬워
- 디버깅이 편해 (React DevTools로 state 확인 가능)

**단점:**
- 코드가 좀 더 복잡해
- 매 타이핑마다 리렌더링 발생

### Uncontrolled Components (비제어 컴포넌트)
DOM이 직접 입력값을 관리하는 방식. ref로 필요할 때만 값을 가져와!

```typescript
const UncontrolledForm = () => {
  const nameRef = useRef<HTMLInputElement>(null);
  const emailRef = useRef<HTMLInputElement>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const formData = {
      name: nameRef.current?.value || '',
      email: emailRef.current?.value || ''
    };
    console.log('제출된 데이터:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        ref={nameRef}
        defaultValue=""  // 초기값만 설정
      />
      <input
        type="email"
        ref={emailRef}
        defaultValue=""
      />
      <button type="submit">제출</button>
    </form>
  );
};
```

**장점:**
- 코드가 간단해
- 성능이 좋아 (리렌더링 없음)
- 기존 HTML 폼과 비슷해서 이해하기 쉬워

**단점:**
- 실시간 검증이 어려워
- React 방식과 맞지 않아
- 디버깅이 어려워

### 언제 뭘 쓸까?

**Controlled 추천:**
- 실시간 검증이 필요할 때
- 입력값에 따라 UI가 바뀌어야 할 때
- 포맷팅이 필요할 때 (전화번호, 금액 등)

**Uncontrolled 추천:**
- 간단한 폼 (제출 시에만 데이터 필요)
- 성능이 중요한 대용량 폼
- 파일 업로드 (`<input type="file" />`)

## 🛠️ 커스텀 Input 컴포넌트 설계

### 기본 Input 컴포넌트
```typescript
import type { TextFieldProps } from '@mui/material';

interface CustomInputProps extends Omit<TextFieldProps, 'variant'> {
  label: string;
  error?: string;
  helperText?: string;
}

const CustomInput: React.FC<CustomInputProps> = ({
  label,
  error,
  helperText,
  ...muiProps
}) => {
  return (
    <TextField
      variant="outlined"
      fullWidth
      label={label}
      error={!!error}
      helperText={error || helperText}
      {...muiProps}  // 나머지 MUI props 전달
    />
  );
};

// 사용 예시
<CustomInput
  label="이메일"
  type="email"
  value={email}
  onChange={(e) => setEmail(e.target.value)}
  error={emailError}
  helperText="올바른 이메일 형식을 입력하세요"
/>
```

### CurrencyInput - 금액 입력 컴포넌트
```typescript
interface CurrencyInputProps extends Omit<TextFieldProps, 'onChange' | 'value'> {
  value: number;
  onChange: (value: number) => void;
  min?: number;
  max?: number;
}

const CurrencyInput: React.FC<CurrencyInputProps> = ({
  value,
  onChange,
  min = 0,
  max = Number.MAX_SAFE_INTEGER,
  ...muiProps
}) => {
  // 화면에 표시할 포맷된 문자열
  const [displayValue, setDisplayValue] = useState(
    value.toLocaleString()
  );

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const input = e.target.value;
    
    // 숫자와 콤마만 허용
    const cleanInput = input.replace(/[^\d,]/g, '');
    
    // 콤마 제거하고 숫자로 변환
    const numericValue = parseInt(cleanInput.replace(/,/g, '')) || 0;
    
    // 범위 체크
    const clampedValue = Math.min(Math.max(numericValue, min), max);
    
    // 포맷된 문자열로 화면 업데이트
    setDisplayValue(clampedValue.toLocaleString());
    
    // 부모에게 숫자값 전달
    onChange(clampedValue);
  };

  // value prop이 변경되면 display 업데이트
  useEffect(() => {
    setDisplayValue(value.toLocaleString());
  }, [value]);

  return (
    <TextField
      {...muiProps}
      value={displayValue}
      onChange={handleChange}
      InputProps={{
        startAdornment: <InputAdornment position="start">₩</InputAdornment>,
        ...muiProps.InputProps
      }}
      inputProps={{
        inputMode: 'numeric',  // 모바일에서 숫자 키패드
        pattern: '[0-9,]*',    // 패턴 명시
        ...muiProps.inputProps
      }}
    />
  );
};

// 사용 예시
const [amount, setAmount] = useState(0);

<CurrencyInput
  label="지출 금액"
  value={amount}
  onChange={setAmount}
  min={0}
  max={10000000}
/>
```

### DateInput - 날짜 입력 컴포넌트
```typescript
interface DateInputProps extends Omit<TextFieldProps, 'onChange' | 'value' | 'type'> {
  value: string; // YYYY-MM-DD 형식
  onChange: (date: string) => void;
  minDate?: string;
  maxDate?: string;
}

const DateInput: React.FC<DateInputProps> = ({
  value,
  onChange,
  minDate,
  maxDate,
  ...muiProps
}) => {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newDate = e.target.value;
    
    // 날짜 유효성 검사
    if (minDate && newDate < minDate) return;
    if (maxDate && newDate > maxDate) return;
    
    onChange(newDate);
  };

  return (
    <TextField
      {...muiProps}
      type="date"
      value={value}
      onChange={handleChange}
      InputLabelProps={{
        shrink: true,  // 라벨이 항상 위에 있도록
        ...muiProps.InputLabelProps
      }}
      inputProps={{
        min: minDate,
        max: maxDate,
        ...muiProps.inputProps
      }}
    />
  );
};

// 사용 예시
const [date, setDate] = useState(new Date().toISOString().split('T')[0]);

<DateInput
  label="지출 날짜"
  value={date}
  onChange={setDate}
  maxDate={new Date().toISOString().split('T')[0]} // 오늘까지만
/>
```

## 🎭 이벤트 객체 수정 기법

### 문제 상황
컴포넌트에서 받은 onChange를 그대로 쓰면 복잡해져:

```typescript
// 부모 컴포넌트에서 이렇게 써야 함
<CurrencyInput
  onChange={(value) => setFormData(prev => ({ ...prev, amount: value }))}
/>

<DateInput
  onChange={(date) => setFormData(prev => ({ ...prev, date }))}
/>

// 너무 복잡해!
```

### 해결책: 이벤트 객체 수정
커스텀 컴포넌트에서 이벤트 객체를 수정해서 일반 input처럼 쓸 수 있게 만들어!

```typescript
const CurrencyInput: React.FC<CurrencyInputProps> = ({
  name,
  onChange,
  ...props
}) => {
  const handleChange = (numericValue: number) => {
    // 가짜 이벤트 객체 만들기
    const fakeEvent = {
      target: {
        name,
        value: numericValue
      }
    } as React.ChangeEvent<HTMLInputElement>;
    
    // 부모의 onChange에 가짜 이벤트 전달
    onChange?.(fakeEvent);
  };

  // 실제 구현...
};

// 이제 이렇게 쓸 수 있어!
const handleFormChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const { name, value } = e.target;
  setFormData(prev => ({ ...prev, [name]: value }));
};

<CurrencyInput
  name="amount"
  onChange={handleFormChange}  // 일반 input과 동일!
/>
```

### 실제 구현 예시
```typescript
interface FormInputProps {
  name: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

const CurrencyInput = ({ name, onChange, ...props }: CurrencyInputProps & FormInputProps) => {
  const [displayValue, setDisplayValue] = useState('0');

  const handleInternalChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const input = e.target.value;
    const numericValue = parseInt(input.replace(/[^\d]/g, '')) || 0;
    
    setDisplayValue(numericValue.toLocaleString());
    
    // 수정된 이벤트 객체 생성
    const modifiedEvent = {
      ...e,
      target: {
        ...e.target,
        name,
        value: numericValue  // 숫자값으로 변경
      }
    };
    
    onChange(modifiedEvent);
  };

  return (
    <TextField
      {...props}
      value={displayValue}
      onChange={handleInternalChange}
      InputProps={{
        startAdornment: <InputAdornment position="start">₩</InputAdornment>
      }}
    />
  );
};
```

## 💡 실제 프로젝트 적용 사례

### ExpenseForm 통합 예시
```typescript
interface ExpenseFormData {
  title: string;
  amount: number;
  category: string;
  date: string;
  paymentMethod: string;
}

const ExpenseForm = () => {
  const [formData, setFormData] = useState<ExpenseFormData>({
    title: '',
    amount: 0,
    category: '',
    date: new Date().toISOString().split('T')[0],
    paymentMethod: ''
  });

  // 모든 input에서 사용할 공통 핸들러
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  return (
    <form>
      <CustomInput
        name="title"
        label="지출 제목"
        value={formData.title}
        onChange={handleChange}
      />
      
      <CurrencyInput
        name="amount"
        label="금액"
        value={formData.amount}
        onChange={handleChange}
      />
      
      <DateInput
        name="date"
        label="날짜"
        value={formData.date}
        onChange={handleChange}
      />
    </form>
  );
};
```

### 실시간 검증 패턴
```typescript
const [errors, setErrors] = useState<Record<string, string>>({});

const validateField = (name: string, value: any) => {
  switch (name) {
    case 'title':
      return value.trim() ? '' : '제목을 입력하세요';
    case 'amount':
      return value > 0 ? '' : '금액을 입력하세요';
    case 'category':
      return value ? '' : '카테고리를 선택하세요';
    default:
      return '';
  }
};

const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const { name, value } = e.target;
  
  // 폼 데이터 업데이트
  setFormData(prev => ({ ...prev, [name]: value }));
  
  // 실시간 검증
  const error = validateField(name, value);
  setErrors(prev => ({ ...prev, [name]: error }));
};

// 컴포넌트에서 에러 표시
<CustomInput
  name="title"
  label="지출 제목"
  value={formData.title}
  onChange={handleChange}
  error={errors.title}
/>
```

## 🎓 핵심 정리

### 1. Controlled vs Uncontrolled
- **Controlled**: React state로 관리, 실시간 제어 가능
- **Uncontrolled**: DOM이 직접 관리, 성능 좋음
- **선택 기준**: 기능 요구사항과 성능 고려

### 2. 커스텀 Input 설계 원칙
- **일관성**: 표준 input과 비슷한 API
- **재사용성**: 다양한 상황에서 쓸 수 있게
- **접근성**: ARIA 레이블, 키보드 네비게이션 고려

### 3. 이벤트 객체 수정
- **목적**: 커스텀 컴포넌트를 표준 input처럼 사용
- **방법**: 가짜 이벤트 객체 생성해서 전달
- **장점**: 폼 처리 로직 통일화 가능

## ⚠️ 주의사항

### 1. 성능 고려사항
```typescript
// 나쁜 예: 매번 새 함수 생성
<input onChange={(e) => handleChange(e, 'fieldName')} />

// 좋은 예: useCallback으로 메모이제이션
const handleFieldChange = useCallback((field: string) => 
  (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData(prev => ({ ...prev, [field]: e.target.value }));
  }, []
);
```

### 2. 타입 안전성
```typescript
// 타입 안전한 폼 데이터 핸들러
const handleChange = <K extends keyof FormData>(
  field: K,
  value: FormData[K]
) => {
  setFormData(prev => ({ ...prev, [field]: value }));
};
```

### 3. 접근성 고려
```typescript
<TextField
  aria-label="지출 금액 입력"
  aria-describedby="amount-helper-text"
  aria-invalid={!!errors.amount}
/>
```

## 🚀 다음 단계
- React Hook Form 라이브러리 활용
- Yup을 이용한 스키마 기반 검증
- 복합 컴포넌트 패턴 (Compound Components)
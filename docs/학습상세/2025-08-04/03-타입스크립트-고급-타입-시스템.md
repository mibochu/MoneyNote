# 타입스크립트 고급 타입 시스템

## 🎯 학습 목표
- 유틸리티 타입들이 뭔지, 언제 쓰는지 알아보자
- Type-only Imports가 뭔지, 왜 필요한지 배우자
- 제네릭을 써서 재사용 가능한 컴포넌트를 만들어보자

## 🤔 이걸 왜 했는가?
MoneyNote 프로젝트에서 TypeScript strict mode를 사용하는데, 여러 문제가 발생했어:
1. MUI 컴포넌트를 확장할 때 불필요한 props까지 다 가져와야 하는 문제
2. `verbatimModuleSyntax` 설정 때문에 타입과 값 import가 구분 안 되는 문제  
3. 비슷한 컴포넌트(Select, MultiSelect 등)를 매번 새로 만들어야 하는 문제

이런 TypeScript 관련 이슈들을 해결하려면 고급 타입 시스템을 제대로 알아야 했어.

## 🛠️ 어떻게 했는가?
1. **유틸리티 타입 적용**: Omit으로 불필요한 props 제거, Pick으로 필요한 것만 선택
2. **Type-only Import 분리**: `import type`으로 타입만 가져와서 컴파일 최적화
3. **제네릭 활용**: Select 컴포넌트를 제네릭으로 만들어서 어떤 타입이든 받을 수 있게
4. **타입 가드 구현**: Union 타입과 함께 런타임 타입 체크
5. **에러 해결**: LinearProgress color prop 같은 복잡한 타입을 명시적 캐스팅으로 해결

## 🛠️ 유틸리티 타입 완전 정복

### Omit - "빼기" 타입
Omit은 기존 타입에서 특정 속성만 빼고 새로운 타입을 만들어.

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

// 패스워드 빼고 나머지만 사용하고 싶을 때
type PublicUser = Omit<User, 'password'>;
// 결과: { id: number; name: string; email: string; }

// 여러 개도 뺄 수 있어!
type UserPreview = Omit<User, 'password' | 'email'>;
// 결과: { id: number; name: string; }
```

**실제 사용 예시:**
```typescript
import type { ButtonProps as MuiButtonProps } from '@mui/material';

// MUI 버튼의 color prop을 빼고 우리만의 loading 추가
interface CustomButtonProps extends Omit<MuiButtonProps, 'color'> {
  loading?: boolean;
}
```

### Pick - "골라내기" 타입
Pick은 반대로 원하는 속성만 골라서 새 타입을 만들어.

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
  createdAt: Date;
}

// 로그인할 때는 이메일과 패스워드만 필요해
type LoginRequest = Pick<User, 'email' | 'password'>;
// 결과: { email: string; password: string; }
```

### Partial - "선택적" 타입
Partial은 모든 속성을 선택적(optional)으로 만들어.

```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

// 업데이트할 때는 일부만 변경할 수 있게
type UserUpdate = Partial<User>;
// 결과: { id?: number; name?: string; email?: string; }

function updateUser(id: number, updates: UserUpdate) {
  // 이제 name만 업데이트하거나, email만 업데이트할 수 있어!
}
```

### Record - "딕셔너리" 타입
Record는 키-값 쌍의 객체 타입을 만들 때 써.

```typescript
// 카테고리별 색상 정의
type CategoryColors = Record<string, string>;

const categoryColors: CategoryColors = {
  '식비': '#ff6b6b',
  '교통비': '#4ecdc4',
  '쇼핑': '#45b7d1'
};

// 더 구체적으로도 쓸 수 있어
type Status = 'pending' | 'approved' | 'rejected';
type StatusMessages = Record<Status, string>;

const messages: StatusMessages = {
  pending: '대기 중',
  approved: '승인됨', 
  rejected: '거절됨'
};
```

## 📦 Type-only Imports

### 왜 Type-only Imports가 필요할까?
TypeScript는 컴파일할 때 타입 정보를 없애. 근데 가끔 "이거 타입인지, 실제 값인지" 헷갈릴 때가 있어.

```typescript
// 나쁜 예: 타입인지 값인지 헷갈려!
import { ButtonProps } from '@mui/material';

// 좋은 예: 이건 타입이야!라고 명확히 표시
import type { ButtonProps } from '@mui/material';
```

### verbatimModuleSyntax 설정
tsconfig.json에서 이 설정을 켜면, 타입과 값을 명확히 구분해야 해.

```json
{
  "compilerOptions": {
    "verbatimModuleSyntax": true
  }
}
```

### 실제 사용 패턴
```typescript
// 타입만 가져올 때
import type { DialogProps } from '@mui/material';
import type { ReactNode } from 'react';

// 실제 컴포넌트나 함수 가져올 때
import { Dialog, DialogTitle } from '@mui/material';
import React from 'react';

// 섞어서 쓸 때는 분리해서!
import { Button } from '@mui/material';
import type { ButtonProps } from '@mui/material';
```

## 🎭 제네릭을 활용한 재사용 컴포넌트

### 제네릭이 뭘까?
제네릭은 "틀"이야. 같은 모양인데 다른 타입을 넣을 수 있는 틀!

```typescript
// 기본 제네릭
interface Box<T> {
  content: T;
}

const stringBox: Box<string> = { content: "안녕하세요" };
const numberBox: Box<number> = { content: 42 };
const userBox: Box<User> = { content: { id: 1, name: "김철수" } };
```

### Select 컴포넌트에 제네릭 적용
```typescript
// 어떤 타입의 옵션이든 받을 수 있는 Select
interface SelectOption<T = string> {
  value: T;
  label: string;
}

interface SelectProps<T = string> {
  options: SelectOption<T>[];
  value?: T;
  onChange: (value: T) => void;
}

// 사용 예시
const stringOptions: SelectOption<string>[] = [
  { value: 'option1', label: '옵션 1' },
  { value: 'option2', label: '옵션 2' }
];

const numberOptions: SelectOption<number>[] = [
  { value: 1, label: '첫 번째' },
  { value: 2, label: '두 번째' }
];
```

### API 응답 타입에 제네릭 활용
```typescript
interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
}

// 사용할 때
type UserResponse = ApiResponse<User>;
type ExpenseListResponse = ApiResponse<Expense[]>;

const fetchUser = async (id: number): Promise<UserResponse> => {
  // API 호출 로직
};
```

## 🔍 고급 타입 기법

### Union 타입과 타입 가드
```typescript
type Theme = 'light' | 'dark' | 'auto';
type Size = 'small' | 'medium' | 'large';

// 타입 가드 함수
function isValidTheme(theme: string): theme is Theme {
  return ['light', 'dark', 'auto'].includes(theme);
}

// 사용 예시
const userTheme = localStorage.getItem('theme');
if (isValidTheme(userTheme)) {
  // 여기서 userTheme은 Theme 타입으로 좁혀짐
  setTheme(userTheme);
}
```

### Mapped Types (맵핑된 타입)
```typescript
// 모든 속성을 읽기 전용으로 만들기
type ReadOnly<T> = {
  readonly [K in keyof T]: T[K];
};

// 모든 속성을 선택적으로 만들기 (Partial과 동일)
type Optional<T> = {
  [K in keyof T]?: T[K];
};

// 실제 사용
interface User {
  id: number;
  name: string;
}

type ReadOnlyUser = ReadOnly<User>;
// 결과: { readonly id: number; readonly name: string; }
```

## 💡 실제 프로젝트 적용 사례

### Modal 컴포넌트 타입 설계
```typescript
import type { DialogProps } from '@mui/material';

interface BaseModalProps extends Omit<DialogProps, 'open' | 'onClose'> {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
}

interface ConfirmModalProps extends BaseModalProps {
  onConfirm: () => void;
  confirmText?: string;
  cancelText?: string;
}
```

### NavigationItem 인터페이스
```typescript
import type { ReactNode } from 'react';

interface NavigationItem {
  path: string;
  label: string;
  icon: ReactNode;
}

interface NavigationProps {
  items: NavigationItem[];
  currentPath: string; 
}
```

### LinearProgress 타입 캐스팅
```typescript
// Material-UI의 color prop 타입이 복잡할 때
const getStatusColor = (status: string) => {
  switch (status) {
    case 'good': return 'success';
    case 'warning': return 'warning';
    case 'danger': return 'error';
    default: return 'primary';
  }
};

// 타입 캐스팅으로 해결
<LinearProgress
  color={getStatusColor(status) as 'primary' | 'secondary' | 'error' | 'info' | 'success' | 'warning'}
/>
```

## 🎓 핵심 정리

### 1. 유틸리티 타입 활용법
- **Omit**: 불필요한 속성 제거
- **Pick**: 필요한 속성만 선택
- **Partial**: 모든 속성을 선택적으로
- **Record**: 키-값 딕셔너리 타입

### 2. Type-only Imports
- `import type`으로 타입임을 명시
- verbatimModuleSyntax 설정과 함께 사용
- 컴파일 시 최적화에 도움

### 3. 제네릭 활용
- 재사용 가능한 컴포넌트/함수 작성
- 타입 안전성 보장
- 코드 중복 제거

## 🔧 타입스크립트 설정 최적화

### tsconfig.json 추천 설정
```json
{
  "compilerOptions": {
    "strict": true,
    "verbatimModuleSyntax": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true
  }
}
```

## 🚀 다음 단계
- 고급 조건부 타입 (Conditional Types)
- 템플릿 리터럴 타입 (Template Literal Types)
- 타입 추론 최적화 기법
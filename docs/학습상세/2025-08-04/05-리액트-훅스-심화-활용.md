# 리액트-훅스-심화-활용

## 🎯 학습 목표
- useState의 함수형 업데이트가 뭔지, 언제 쓰는지 알아보자
- useEffect 의존성 배열을 제대로 관리하는 방법을 배우자
- React.memo와 메모이제이션으로 성능을 높이는 비법을 익히자

## 🤔 이걸 왜 했는가?
MoneyNote에서 여러 컴포넌트를 만들다 보니 성능 문제와 상태 관리 이슈가 생겼어:
1. **빠른 클릭 시 상태 업데이트 누락**: 버튼을 연속으로 클릭하면 카운트가 제대로 안 올라가는 문제
2. **불필요한 리렌더링**: 부모 컴포넌트가 리렌더링될 때마다 모든 자식들도 리렌더링
3. **useEffect 무한 루프**: 의존성 배열을 잘못 설정해서 계속 실행되는 문제

이런 React Hooks 관련 문제들을 해결하려면 심화 개념이 필요했어.

## 🛠️ 어떻게 했는가?
1. **함수형 업데이트 도입**: `setState(prev => prev + 1)` 방식으로 최신 상태 보장
2. **의존성 배열 최적화**: 필요한 것만 넣고, 함수형 업데이트로 의존성 최소화
3. **React.memo 적용**: ExpenseItem 같은 리스트 아이템에 memo 적용해서 불필요한 리렌더링 방지
4. **useMemo/useCallback 활용**: 비싼 계산과 함수를 메모해서 성능 향상
5. **성능 측정**: console.log로 실제 렌더링 횟수 확인하면서 최적화 효과 검증

## 🔄 useState 함수형 업데이트 패턴

### 기본 useState vs 함수형 업데이트
```typescript
const [count, setCount] = useState(0);

// 일반적인 방법
const handleIncrement = () => {
  setCount(count + 1); // 현재 count 값을 직접 사용
};

// 함수형 업데이트 방법 
const handleIncrement = () => {
  setCount(prev => prev + 1); // 이전 값을 받아서 처리
};
```

### 왜 함수형 업데이트를 쓸까?

**1. 최신 상태 보장**
```typescript
// 문제 상황: 빠르게 클릭하면 값이 제대로 안 올라가
const BadCounter = () => {
  const [count, setCount] = useState(0);
  
  const handleDouble = () => {
    setCount(count + 1); // 첫 번째 업데이트
    setCount(count + 1); // 두 번째 업데이트 (여전히 같은 count 사용!)
    // 결과: 1만 증가 (2가 아니라!)
  };
};

// 해결: 함수형 업데이트
const GoodCounter = () => {
  const [count, setCount] = useState(0);
  
  const handleDouble = () => {
    setCount(prev => prev + 1); // 첫 번째 업데이트
    setCount(prev => prev + 1); // 두 번째 업데이트 (최신 값 사용!)
    // 결과: 2 증가!
  };
};
```

**2. useEffect 의존성 제거**
```typescript
// 문제: count가 의존성에 있어야 함
const BadComponent = () => {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count + 1); // count를 직접 사용
    }, 1000);
    
    return () => clearInterval(timer);
  }, [count]); // count가 바뀔 때마다 타이머 재생성!
};

// 해결: 의존성 배열이 비어도 됨
const GoodComponent = () => {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(prev => prev + 1); // 함수형 업데이트
    }, 1000);
    
    return () => clearInterval(timer);
  }, []); // 빈 배열! 한 번만 실행
};
```

### 복잡한 상태 업데이트
```typescript
interface TodoItem {
  id: number;
  text: string;
  completed: boolean;
}

const [todos, setTodos] = useState<TodoItem[]>([]);

// 할 일 추가
const addTodo = (text: string) => {
  setTodos(prev => [
    ...prev,
    { id: Date.now(), text, completed: false }
  ]);
};

// 할 일 완료 토글
const toggleTodo = (id: number) => {
  setTodos(prev => prev.map(todo =>
    todo.id === id 
      ? { ...todo, completed: !todo.completed }
      : todo
  ));
};

// 할 일 삭제
const deleteTodo = (id: number) => {
  setTodos(prev => prev.filter(todo => todo.id !== id));
};
```

## ⚡ useEffect 의존성 배열 관리

### 의존성 배열이 뭘까?
useEffect의 두 번째 인자야. "이 값들이 바뀔 때마다 effect를 다시 실행해"라는 뜻!

```typescript
useEffect(() => {
  // 이 함수가 실행될 조건
}, [/* 이 배열의 값들이 바뀔 때 */]);
```

### 의존성 배열 패턴들

**1. 빈 배열 [] - 마운트 시 한 번만**
```typescript
useEffect(() => {
  console.log('컴포넌트가 처음 나타날 때만 실행');
  
  // API 호출, 이벤트 리스너 등록 등
  fetchInitialData();
  
  return () => {
    console.log('컴포넌트가 사라질 때 실행');
    // 정리 작업
  };
}, []); // 빈 배열
```

**2. 의존성 없음 - 매 렌더링마다**
```typescript
useEffect(() => {
  console.log('매번 실행됨 (보통 안 씀)');
}); // 의존성 배열 없음
```

**3. 특정 값 변화 시**
```typescript
const [user, setUser] = useState(null);
const [posts, setPosts] = useState([]);

useEffect(() => {
  if (user) {
    fetchUserPosts(user.id);
  }
}, [user]); // user가 바뀔 때마다 실행
```

### 의존성 배열 실수들과 해결법

**실수 1: 빠뜨린 의존성**
```typescript
// 잘못된 예
const BadComponent = ({ userId }) => {
  const [userData, setUserData] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUserData); // userId 사용하는데
  }, []); // 의존성에 없음!
  
  // userId가 바뀌어도 새 데이터를 안 가져와
};

// 올바른 예
const GoodComponent = ({ userId }) => {
  const [userData, setUserData] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUserData);
  }, [userId]); // userId를 의존성에 추가!
};
```

**실수 2: 불필요한 의존성**
```typescript
// 문제가 있는 예
const ProblematicComponent = () => {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  useEffect(() => {
    document.title = `카운트: ${count}`;
  }, [count, name]); // name은 사용하지 않는데 의존성에 있음
  
  // name이 바뀔 때도 불필요하게 실행됨!
};

// 해결된 예
const FixedComponent = () => {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  useEffect(() => {
    document.title = `카운트: ${count}`;
  }, [count]); // count만 의존성에!
};
```

## 🧠 React.memo와 메모이제이션 전략

### React.memo란?
컴포넌트를 "기억"해서, props가 바뀌지 않으면 다시 렌더링하지 않는 기능!

```typescript
// 기본 컴포넌트 (항상 리렌더링)
const ExpensiveComponent = ({ data }) => {
  console.log('렌더링됨!'); // 부모가 리렌더링될 때마다 실행
  
  return <div>{data.name}</div>;
};

// memo로 감싼 컴포넌트 (props 바뀔 때만 리렌더링)
const OptimizedComponent = React.memo(({ data }) => {
  console.log('필요할 때만 렌더링됨!');
  
  return <div>{data.name}</div>;
});
```

### 언제 React.memo를 쓸까?

**쓰면 좋은 경우:**
- 렌더링 비용이 큰 컴포넌트
- props가 자주 바뀌지 않는 컴포넌트
- 목록의 아이템 컴포넌트

**쓰지 않아도 되는 경우:**
- 간단한 컴포넌트
- props가 항상 바뀌는 컴포넌트

### 실제 사용 예시

**ExpenseItem 컴포넌트 최적화:**
```typescript
interface ExpenseItemProps {
  expense: {
    id: number;
    title: string;
    amount: number;
    category: string;
  };
  onEdit: (id: number) => void;
  onDelete: (id: number) => void;
}

// memo로 감싸서 최적화
const ExpenseItem = React.memo<ExpenseItemProps>(({ expense, onEdit, onDelete }) => {
  console.log('ExpenseItem 렌더링:', expense.id);
  
  return (
    <ListItem>
      <ListItemText 
        primary={expense.title}
        secondary={`${expense.amount.toLocaleString()}원 - ${expense.category}`}
      />
      <IconButton onClick={() => onEdit(expense.id)}>
        <Edit />
      </IconButton>
      <IconButton onClick={() => onDelete(expense.id)}>
        <Delete />
      </IconButton>
    </ListItem>
  );
});
```

### useMemo와 useCallback

**useMemo - 계산 결과 기억하기:**
```typescript
const ExpenseList = ({ expenses }) => {
  // 비싼 계산을 메모해서 expenses가 바뀔 때만 다시 계산
  const totalAmount = useMemo(() => {
    console.log('총액 계산 중...');
    return expenses.reduce((sum, expense) => sum + expense.amount, 0);
  }, [expenses]);
  
  const monthlyAverage = useMemo(() => {
    console.log('월평균 계산 중...');
    return totalAmount / 12;
  }, [totalAmount]);
  
  return (
    <div>
      <p>총 지출: {totalAmount.toLocaleString()}원</p>
      <p>월 평균: {monthlyAverage.toLocaleString()}원</p>
    </div>
  );
};
```

**useCallback - 함수 기억하기:**
```typescript
const ExpenseManager = () => {
  const [expenses, setExpenses] = useState([]);
  
  // 함수를 메모해서 매번 새로 만들지 않기
  const handleDelete = useCallback((id: number) => {
    setExpenses(prev => prev.filter(expense => expense.id !== id));
  }, []); // expenses에 의존하지 않도록 함수형 업데이트 사용
  
  const handleEdit = useCallback((id: number) => {
    // 편집 로직
  }, []);
  
  return (
    <div>
      {expenses.map(expense => (
        <ExpenseItem
          key={expense.id}
          expense={expense}
          onDelete={handleDelete} // 같은 함수 참조 전달
          onEdit={handleEdit}
        />
      ))}
    </div>
  );
};
```

## 💡 실제 프로젝트 적용 사례

### Navigation 컴포넌트 최적화
```typescript
// 현재 경로가 바뀔 때만 리렌더링되도록
const Navigation = React.memo(() => {
  const location = useLocation();
  
  const navigationItems = useMemo(() => [
    { path: '/', label: '대시보드', icon: <Dashboard /> },
    { path: '/expenses', label: '지출', icon: <Receipt /> },
    // ...
  ], []); // 정적 데이터는 빈 의존성
  
  return (
    <BottomNavigation>
      {navigationItems.map((item) => (
        <BottomNavigationAction
          key={item.path}
          selected={location.pathname === item.path}
          // ...
        />
      ))}
    </BottomNavigation>
  );
});
```

### Dashboard 요약 카드 최적화
```typescript
interface SummaryCardProps {
  title: string;
  amount: number;
  color: 'primary' | 'error' | 'success' | 'info';
}

// 카드 컴포넌트는 props가 바뀔 때만 리렌더링
const SummaryCard = React.memo<SummaryCardProps>(({ title, amount, color }) => {
  const formattedAmount = useMemo(() => {
    return `₩${amount.toLocaleString()}`;
  }, [amount]);
  
  return (
    <Card>
      <CardContent>
        <Typography variant="h6">{title}</Typography>
        <Typography variant="h4" color={color}>
          {formattedAmount}
        </Typography>
      </CardContent>
    </Card>
  );
});
```

## 🎓 핵심 정리

### 1. useState 함수형 업데이트
- **언제 쓸까**: 이전 상태를 기반으로 업데이트할 때
- **장점**: 최신 상태 보장, useEffect 의존성 최소화
- **패턴**: `setState(prev => 새로운값)`

### 2. useEffect 의존성 관리
- **빈 배열 []**: 마운트 시 한 번
- **특정 값**: 해당 값 변화 시
- **원칙**: 사용하는 모든 값을 의존성에 포함

### 3. 메모이제이션 전략
- **React.memo**: 컴포넌트 리렌더링 최적화
- **useMemo**: 계산 결과 캐싱
- **useCallback**: 함수 참조 고정

## ⚠️ 주의사항

### 1. 과도한 최적화 금지
```typescript
// 이런 간단한 컴포넌트는 memo 필요 없어
const SimpleText = React.memo(({ text }) => <p>{text}</p>);

// 차라리 이렇게
const SimpleText = ({ text }) => <p>{text}</p>;
```

### 2. 의존성 배열 완전성
ESLint 규칙 `exhaustive-deps`를 켜서 놓친 의존성을 찾자!

### 3. 참조 동등성 주의
```typescript
// 이건 매번 새 객체라서 memo 효과 없음
<ExpenseItem expense={{ id: 1, name: 'test' }} />

// 이렇게 변수로 빼거나
const expense = { id: 1, name: 'test' };
<ExpenseItem expense={expense} />

// useMemo로 메모하기
const expense = useMemo(() => ({ id: 1, name: 'test' }), []);
```

## 🚀 다음 단계
- Custom Hooks 만들기 (재사용 가능한 로직)
- useReducer로 복잡한 상태 관리
- React DevTools로 성능 프로파일링
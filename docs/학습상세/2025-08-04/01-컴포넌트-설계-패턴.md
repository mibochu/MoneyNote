# 컴포넌트 설계 패턴

## 🎯 학습 목표
- Props 인터페이스를 잘 설계하는 방법을 배우자
- 컴포넌트를 가족처럼 묶어서 관리하는 방법을 알아보자
- 재사용하기 좋은 컴포넌트를 만드는 비법을 익히자

## 🤔 이걸 왜 했는가?
MoneyNote 프로젝트에서 UI 컴포넌트 시스템을 구축하면서, 같은 기능을 하는 컴포넌트들(Button, IconButton, Fab)을 만들어야 했어. 각각 따로 만들다 보니 코드 중복이 많고, props 설계도 일관성이 없어서 유지보수가 어려웠지. 그래서 체계적인 컴포넌트 설계 패턴이 필요했어.

## 🛠️ 어떻게 했는가?
1. **문제 파악**: 비슷한 컴포넌트들의 코드 중복과 props 불일치 발견
2. **TypeScript 활용**: Omit, extends를 써서 기존 MUI props 확장
3. **폴더 구조화**: 관련 컴포넌트들을 하나의 폴더에 모으기
4. **Barrel Export**: index.ts로 깔끔한 import/export 시스템 구축
5. **단일 책임 원칙**: 각 컴포넌트가 하나의 역할만 하도록 설계

## 📝 Props 인터페이스 설계하기

### 기본 개념 (초등학생도 이해할 수 있게!)
Props는 컴포넌트에게 전달하는 "정보"야. 마치 친구에게 편지를 쓸 때 "누구에게", "무슨 내용"을 적는 것처럼!

```typescript
// 나쁜 예: 뭐가 뭔지 모르겠어!
interface BadProps {
  data: any;
  onClick: any;
}

// 좋은 예: 한눈에 알 수 있어!
interface GoodButtonProps {
  children: React.ReactNode;  // 버튼 안에 들어갈 글자나 아이콘
  onClick: () => void;        // 클릭했을 때 할 일
  loading?: boolean;          // 로딩 중인지 아닌지
  size?: 'small' | 'medium' | 'large';  // 버튼 크기
}
```

### Omit 타입 활용하기
Omit은 "빼기"야! 기존 타입에서 필요 없는 부분을 빼고 새로 만들 때 써.

```typescript
import type { ButtonProps as MuiButtonProps } from '@mui/material';

// MUI 버튼에서 color만 빼고 나머지는 다 가져와!
interface CustomButtonProps extends Omit<MuiButtonProps, 'color'> {
  loading?: boolean;
  // 우리만의 특별한 props 추가
}
```

### Union 타입으로 선택지 만들기
Union 타입은 "이것 또는 저것" 중에 하나를 고르는 거야!

```typescript
interface NavigationProps {
  variant: 'mobile' | 'desktop';  // 모바일용 또는 데스크톱용
  position: 'top' | 'bottom' | 'side';  // 위, 아래, 옆 중 하나
}
```

## 🏗️ 컴포넌트 패밀리 구조

### 폴더로 가족 만들기
비슷한 컴포넌트들을 한 폴더에 모아두면 찾기 쉬워!

```
src/components/ui/Button/
├── Button.tsx          // 기본 버튼 (엄마)
├── IconButton.tsx      // 아이콘 버튼 (첫째)
├── Fab.tsx            // 동그란 버튼 (둘째)
├── index.ts           // 가족 소개서
└── Button.stories.tsx  // 가족 앨범
```

### 단일 책임 원칙
하나의 컴포넌트는 한 가지 일만 잘하면 돼!

```typescript
// ✅ 좋은 예: 버튼은 클릭만 담당
const Button = ({ children, onClick, loading }) => {
  return (
    <MuiButton onClick={onClick} disabled={loading}>
      {loading ? <CircularProgress size={20} /> : children}
    </MuiButton>
  );
};

// ❌ 나쁜 예: 버튼이 너무 많은 일을 해
const Button = ({ children, onClick, loading, fetchData, validateForm }) => {
  // 버튼인데 데이터도 가져오고, 폼도 검증하고... 너무 바빠!
};
```

## 📦 Barrel Export 패턴

### index.ts로 깔끔하게 정리하기
index.ts는 "목차" 같은 거야. 어떤 컴포넌트들이 있는지 한눈에 보여줘!

```typescript
// src/components/ui/Button/index.ts
export { default as Button } from './Button';
export { default as IconButton } from './IconButton';
export { default as Fab } from './Fab';

// 이제 이렇게 간단하게 가져올 수 있어!
import { Button, IconButton, Fab } from '@/components/ui/Button';
```

## 💡 실제 적용 사례

### Layout 컴포넌트 설계
```typescript
interface LayoutProps {
  children: React.ReactNode;
  maxWidth?: 'xs' | 'sm' | 'md' | 'lg' | 'xl' | false;
  background?: 'default' | 'paper';
  padding?: boolean;
}

// 사용하기 쉽게 기본값 설정
const Layout: React.FC<LayoutProps> = ({
  children,
  maxWidth = 'lg',      // 기본은 lg 크기
  background = 'default', // 기본은 일반 배경
  padding = true        // 기본은 여백 있음
}) => {
  // ...
};
```

### Navigation 컴포넌트 설계
```typescript
interface NavigationItem {
  path: string;    // 어디로 갈지
  label: string;   // 버튼에 쓸 글자
  icon: React.ReactNode;  // 아이콘
}

interface NavigationProps {
  items: NavigationItem[];  // 메뉴 목록
  currentPath: string;      // 지금 어디에 있는지
}
```

## 🎓 핵심 정리

### 1. Props 설계 3원칙
1. **명확하게**: 이름만 봐도 뭔지 알 수 있게
2. **간단하게**: 너무 복잡하지 않게
3. **안전하게**: TypeScript로 타입 체크

### 2. 컴포넌트 가족 만들기
1. **폴더로 그룹핑**: 비슷한 애들끼리 모으기
2. **단일 책임**: 하나의 컴포넌트는 한 가지 일만
3. **index.ts**: 깔끔한 import/export

### 3. 재사용성 높이기
1. **기본값 설정**: 자주 쓰는 값은 기본으로
2. **확장 가능**: 나중에 기능 추가하기 쉽게
3. **일관성 유지**: 비슷한 컴포넌트는 비슷한 방식으로

## 🚀 다음 단계
- 컴포넌트 테스트 작성해보기
- Storybook으로 컴포넌트 문서화하기
- 디자인 시스템 구축하기
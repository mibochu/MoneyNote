# 리액트 라우터 고급 활용

## 🎯 학습 목표
- 중첩 라우팅이 뭔지, 왜 쓰는지 알아보자
- Outlet으로 레이아웃을 공유하는 방법을 배우자
- 동적으로 네비게이션 상태를 관리하는 비법을 익히자

## 🤔 이걸 왜 했는가?
MoneyNote에서 여러 페이지(Dashboard, Expenses, Budget 등)를 만들어야 하는데, 모든 페이지에서 같은 네비게이션과 레이아웃을 써야 했어. 페이지마다 네비게이션을 복붙하면 코드 중복이 심하고, 나중에 네비게이션을 수정할 때 모든 페이지를 다 바꿔야 하는 문제가 있었지. 그래서 공통 레이아웃을 공유하는 방법이 필요했어.

## 🛠️ 어떻게 했는가?
1. **라우터 구조 설계**: AppLayout을 최상위로 하고 개별 페이지를 중첩 구조로 배치
2. **Outlet 적용**: AppLayout에서 Outlet을 써서 자식 컴포넌트가 들어올 자리 만들기
3. **반응형 네비게이션**: useMediaQuery로 모바일/데스크톱 구분해서 다른 네비게이션 보여주기
4. **현재 경로 감지**: useLocation으로 어느 페이지에 있는지 파악해서 활성 상태 표시
5. **동적 이동**: useNavigate로 프로그래밍 방식 페이지 이동 구현

## 🗺️ React Router 기본 개념

### 라우팅이란?
라우팅은 "길찾기"야! 웹사이트에서 주소가 바뀔 때마다 어떤 페이지를 보여줄지 정하는 거지.

```typescript
// 예시: 이런 주소들이 있다면
// /dashboard -> 대시보드 페이지
// /expenses -> 지출 관리 페이지
// /budget -> 예산 관리 페이지
```

### SPA (Single Page Application)
우리가 만드는 앱은 SPA야. 페이지가 하나인데, 주소에 따라 다른 내용을 보여주는 마법 같은 기술!

## 🏗️ 중첩 라우팅 (Nested Routing)

### 왜 중첩 라우팅을 쓸까?
공통으로 쓰는 부분(헤더, 네비게이션)은 그대로 두고, 내용만 바뀌게 하려고!

```typescript
// App.tsx - 최상위 라우터 설정
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* 이 부분이 중첩 라우팅의 핵심! */}
        <Route path="/" element={<AppLayout />}>
          <Route index element={<Dashboard />} />
          <Route path="expenses" element={<Expenses />} />
          <Route path="budget" element={<Budget />} />
          <Route path="reports" element={<Reports />} />
          <Route path="settings" element={<Settings />} />
        </Route>
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}
```

### 중첩 구조 이해하기
```
앱 전체 레이아웃 (AppLayout)
├── 네비게이션 (고정)
├── 헤더 (고정)
└── 내용 영역 ← 여기만 바뀜! (Outlet)
    ├── / → Dashboard
    ├── /expenses → Expenses
    ├── /budget → Budget
    └── ...
```

## 🚪 Outlet으로 레이아웃 공유하기

### Outlet이란?
Outlet은 "구멍"이야! 이 구멍을 통해서 자식 컴포넌트들이 들어와.

```typescript
// AppLayout.tsx
import { Outlet } from 'react-router-dom';

const AppLayout: React.FC = () => {
  return (
    <Box sx={{ display: 'flex', height: '100vh' }}>
      {/* 사이드 네비게이션 - 항상 보임 */}
      <SideNavigation />
      
      {/* 메인 컨텐츠 영역 */}
      <Box component="main" sx={{ flexGrow: 1, p: 3 }}>
        {/* 여기에 자식 컴포넌트가 들어와! */}
        <Outlet />
      </Box>
      
      {/* 모바일 하단 네비게이션 */}
      <Navigation />
    </Box>
  );
};
```

### 실제 동작 방식
```typescript
// 사용자가 /expenses로 이동하면
<AppLayout>
  {/* 고정 부분들 */}
  <SideNavigation />
  
  {/* Outlet 자리에 Expenses 컴포넌트가 들어감 */}
  <Expenses />
  
  <Navigation />
</AppLayout>
```

## 📱 동적 네비게이션 상태 관리

### useLocation으로 현재 위치 파악하기
```typescript
import { useLocation } from 'react-router-dom';

const Navigation: React.FC = () => {
  const location = useLocation(); // 현재 주소 정보를 가져와
  
  const navigationItems = [
    { path: '/', label: '대시보드', icon: <Dashboard /> },
    { path: '/expenses', label: '지출', icon: <Receipt /> },
    // ...
  ];

  return (
    <BottomNavigation>
      {navigationItems.map((item) => (
        <BottomNavigationAction
          key={item.path}
          label={item.label}
          icon={item.icon}
          // 현재 경로와 같으면 선택된 상태로 표시
          selected={location.pathname === item.path}
        />
      ))}
    </BottomNavigation>
  );
};
```

### useNavigate로 페이지 이동하기
```typescript
import { useNavigate } from 'react-router-dom';

const NotFound: React.FC = () => {
  const navigate = useNavigate();

  const handleGoHome = () => {
    navigate('/'); // 홈으로 이동
  };

  const handleGoBack = () => {
    navigate(-1); // 뒤로 가기 (브라우저 뒤로가기와 같음)
  };

  return (
    <Box>
      <Button onClick={handleGoHome}>홈으로 가기</Button>
      <Button onClick={handleGoBack}>뒤로 가기</Button>
    </Box>
  );
};
```

## 📐 반응형 네비게이션 구현

### 브레이크포인트 기반 네비게이션
```typescript
const AppLayout: React.FC = () => {
  const theme = useTheme();
  // md 이상에서는 데스크톱, 미만에서는 모바일
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));

  return (
    <Box sx={{ display: 'flex', height: '100vh' }}>
      {/* 데스크톱에서만 사이드바 보이기 */}
      {!isMobile && <SideNavigation />}
      
      <Box 
        component="main" 
        sx={{ 
          flexGrow: 1,
          // 사이드바 있을 때와 없을 때 너비 조정
          ml: !isMobile ? '240px' : 0,
          // 모바일에서는 하단 네비게이션 공간 확보
          pb: isMobile ? 8 : 0
        }}
      >
        <Outlet />
      </Box>
      
      {/* 모바일에서만 하단 네비게이션 보이기 */}
      {isMobile && <Navigation />}
    </Box>
  );
};
```

## 🔍 고급 라우팅 기법

### Protected Routes (보호된 라우트)
```typescript
// 로그인한 사용자만 접근 가능한 페이지
const ProtectedRoute = ({ children }: { children: React.ReactNode }) => {
  const isLoggedIn = false; // 실제로는 Context에서 가져와야 함
  
  if (!isLoggedIn) {
    return <Navigate to="/login" replace />;
  }
  
  return <>{children}</>;
};

// 사용 예시
<Route path="/settings" element={
  <ProtectedRoute>
    <Settings />
  </ProtectedRoute>
} />
```

### 동적 라우트 (Dynamic Routes)
```typescript
// URL 파라미터를 받는 라우트
<Route path="/expenses/:id" element={<ExpenseDetail />} />

// ExpenseDetail 컴포넌트에서 사용
const ExpenseDetail = () => {
  const { id } = useParams(); // URL에서 id 파라미터 가져오기
  
  return <div>지출 ID: {id}</div>;
};
```

## 💡 실제 프로젝트 적용 사례

### 우리 프로젝트의 라우터 구조
```typescript
<Routes>
  <Route path="/" element={<AppLayout />}>
    <Route index element={<Dashboard />} />           {/* / */}
    <Route path="expenses" element={<Expenses />} />  {/* /expenses */}
    <Route path="budget" element={<Budget />} />      {/* /budget */}
    <Route path="reports" element={<Reports />} />    {/* /reports */}
    <Route path="settings" element={<Settings />} />  {/* /settings */}
  </Route>
  <Route path="*" element={<NotFound />} />          {/* 404 페이지 */}
</Routes>
```

### 네비게이션 아이템 정의
```typescript
const navigationItems: NavigationItem[] = [
  {
    path: '/',
    label: '대시보드',
    icon: <Dashboard />
  },
  {
    path: '/expenses',
    label: '지출',
    icon: <Receipt />
  },
  // ...
];
```

## 🎓 핵심 정리

### 1. 중첩 라우팅의 장점
- **코드 재사용**: 공통 레이아웃을 한 번만 정의
- **일관성**: 모든 페이지에서 같은 네비게이션
- **성능**: 불필요한 리렌더링 방지

### 2. Outlet 활용법
- 부모 컴포넌트에서 `<Outlet />` 사용
- 자식 라우트가 이 자리에 렌더링됨
- 레이아웃과 콘텐츠 분리

### 3. 동적 네비게이션
- `useLocation`으로 현재 경로 감지
- `useNavigate`로 프로그래밍 방식 이동
- 반응형 디자인으로 모바일/데스크톱 대응

## 🚀 다음 단계
- React Router v7의 새로운 기능들 탐험
- 라우트 기반 코드 스플리팅 (lazy loading)
- 브라우저 히스토리 고급 조작법
# 복합 컴포넌트 설계 패턴

## 🎯 학습 목표
큰 기능을 작은 컴포넌트들로 나누어 관리하는 Container/Presentational 패턴을 익히고, 컴포넌트 간 데이터 흐름을 효율적으로 설계하는 방법을 배우자.

## 🤔 이걸 왜 했는가?

### 문제 상황
지출 목록 기능을 구현하려고 하는데, 한 컴포넌트에 모든 기능을 넣으면:
- 필터링, 정렬, 페이지네이션, 통계 계산... 너무 복잡해진다
- 코드가 1000줄이 넘어가면 유지보수가 어렵다
- 기능별로 테스트하기 어렵다
- 재사용하기 어렵다

### 해결 아이디어
"큰 문제를 작은 문제들로 나누자!"
- ExpenseList: 전체 목록 관리 (필터링, 정렬, 페이지네이션)
- ExpenseItem: 개별 항목 표시 (클릭, 호버, 메뉴)
- Dialog들: 수정, 삭제 각각 독립적으로

## 🛠️ 어떻게 했는가?

### 1단계: 역할 분리하기

#### ExpenseList의 역할 (Container)
```typescript
// 데이터 관리와 비즈니스 로직 담당
const ExpenseList: React.FC<ExpenseListProps> = ({
  expenses,      // 데이터 받기
  onExpenseEdit, // 이벤트 전달하기
  onExpenseDelete,
  filter,        // 상태 관리
  onFilterChange
}) => {
  // 복잡한 계산 로직들
  const filteredExpenses = useMemo(() => { ... });
  const sortedExpenses = useMemo(() => { ... });
  const stats = useMemo(() => { ... });
  
  return (
    <Box>
      {/* UI는 단순하게 */}
      <Stack spacing={1}>
        {paginatedExpenses.map((expense) => (
          <ExpenseItem
            expense={expense}
            onEdit={onExpenseEdit}
            onDelete={onExpenseDelete}
          />
        ))}
      </Stack>
    </Box>
  );
};
```

#### ExpenseItem의 역할 (Presentational)
```typescript
// 표시와 사용자 인터랙션 담당
const ExpenseItem: React.FC<ExpenseItemProps> = ({
  expense,  // 표시할 데이터만 받기
  onEdit,   // 이벤트만 전달하기
  onDelete
}) => {
  // 로컬 상태만 관리
  const [anchorEl, setAnchorEl] = useState(null);
  const [isHovered, setIsHovered] = useState(false);
  
  return (
    <Card onClick={() => onClick?.(expense)}>
      {/* 예쁘게 보여주기만 하기 */}
    </Card>
  );
};
```

### 2단계: 데이터 흐름 설계하기

#### 위에서 아래로: Props 전달
```
Expenses 페이지
    ↓ (expenses, onEdit, onDelete)
ExpenseList
    ↓ (expense, onEdit, onDelete)  
ExpenseItem
```

#### 아래에서 위로: 이벤트 버블링
```
ExpenseItem (편집 버튼 클릭)
    ↑ onEdit(expense)
ExpenseList (이벤트 전달)
    ↑ onExpenseEdit(expense)
Expenses 페이지 (다이얼로그 열기)
```

### 3단계: 인터페이스 정의하기

```typescript
// 각 컴포넌트가 정확히 무엇을 받고 무엇을 하는지 명확히
export interface ExpenseListProps {
  // 필수: 표시할 데이터
  expenses: Expense[];
  
  // 선택적: 상태들
  loading?: boolean;
  error?: string | null;
  
  // 필수: 이벤트 핸들러들
  onExpenseEdit: (expense: Expense) => void;
  onExpenseDelete: (expenseId: string) => void;
  
  // 선택적: 설정들
  filter?: ExpenseFilter;
  onFilterChange?: (filter: ExpenseFilter) => void;
  pageSize?: number;
}
```

## 📚 배운 핵심 개념들

### Container vs Presentational 패턴

#### Container 컴포넌트 (ExpenseList)
- **역할**: "무엇을 할지" 결정
- **책임**: 데이터 가져오기, 상태 관리, 비즈니스 로직
- **특징**: 
  - useMemo, useCallback 같은 최적화 훅 사용
  - 복잡한 계산 로직 포함
  - 다른 컴포넌트들을 조합

#### Presentational 컴포넌트 (ExpenseItem)
- **역할**: "어떻게 보일지" 결정  
- **책임**: UI 표시, 사용자 인터랙션 처리
- **특징**:
  - props로 받은 데이터만 표시
  - 로컬 UI 상태만 관리 (호버, 메뉴 열림 등)
  - 재사용 가능하도록 설계

### Props Drilling 해결법

#### 문제: 깊은 전달
```typescript
// 이렇게 하면 중간 컴포넌트들이 불필요한 props를 받게 됨
<ExpenseList>
  <FilterSection onFilterChange={onFilterChange} />
  <StatsSection />
  <ExpenseItem onEdit={onEdit} onDelete={onDelete} />
</ExpenseList>
```

#### 해결: 컴포넌트 합성
```typescript
// 각 컴포넌트가 필요한 것만 받도록
const ExpenseList = ({ expenses, onExpenseEdit, onExpenseDelete }) => (
  <Box>
    <FilterSection filter={filter} onFilterChange={onFilterChange} />
    <StatsSection expenses={filteredExpenses} />
    {paginatedExpenses.map(expense => (
      <ExpenseItem 
        key={expense.id}
        expense={expense} 
        onEdit={onExpenseEdit}
        onDelete={onExpenseDelete} 
      />
    ))}
  </Box>
);
```

## 💡 중요한 깨달음들

### 1. 단일 책임 원칙 (SRP)
한 컴포넌트는 한 가지 일만 잘해야 한다:
- ExpenseList → 목록 관리만
- ExpenseItem → 항목 표시만  
- ExpenseEditDialog → 수정만

### 2. 인터페이스의 힘
TypeScript 인터페이스로 컴포넌트가 "약속"을 명확히 하면:
- 다른 개발자가 사용하기 쉽다
- 컴파일러가 실수를 잡아준다
- 리팩토링이 안전해진다

### 3. 이벤트 버블링과 stopPropagation
```typescript
const handleMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
  event.stopPropagation(); // 부모의 클릭 이벤트 막기!
  setAnchorEl(event.currentTarget);
};
```
카드를 클릭하면 선택되고, 메뉴 버튼을 클릭하면 메뉴만 열리도록 하려면 이벤트 전파를 제어해야 한다.

## 🔍 실전 적용 팁

### 1. 컴포넌트 나누기 기준
- **기능별**: 필터링, 정렬, 페이지네이션
- **재사용성**: 다른 곳에서도 쓸 수 있는가?
- **복잡도**: 100줄 넘으면 나누기 고려
- **테스트**: 독립적으로 테스트 가능한가?

### 2. Props 설계 원칙
```typescript
// ✅ 좋은 Props 설계
interface ExpenseItemProps {
  expense: Expense;        // 필요한 데이터만
  onEdit: (expense: Expense) => void;  // 명확한 함수 시그니처
  onDelete: (id: string) => void;      // ID만 있으면 충분
  compact?: boolean;       // 선택적 설정
}

// ❌ 나쁜 Props 설계
interface BadProps {
  data: any;              // 너무 모호함
  callbacks: object;      // 어떤 콜백들이 있는지 모름
  allExpenses: Expense[]; // 불필요한 데이터까지
}
```

### 3. 성능 고려사항
```typescript
// 리스트에서는 key가 매우 중요!
{expenses.map((expense) => (
  <ExpenseItem
    key={expense.id}  // 안정적인 고유 식별자
    expense={expense}
  />
))}

// 콜백 함수들도 메모이제이션
const handleExpenseEdit = useCallback((expense: Expense) => {
  setEditingExpense(expense);
}, []);
```

## 🚀 다음 단계

### 배운 것을 어디에 적용할까?
1. **카테고리 관리**: CategoryList + CategoryItem 패턴
2. **대시보드**: Dashboard + 여러 Summary 컴포넌트들
3. **리포트**: ReportContainer + Chart 컴포넌트들

### 더 배우고 싶은 것들
- **Compound Components**: React.Children을 활용한 유연한 컴포넌트
- **Render Props**: 렌더링 로직을 props로 전달하는 패턴
- **Higher-Order Components**: 컴포넌트를 받아 컴포넌트를 리턴하는 함수

## 📝 핵심 정리

1. **복잡한 UI = 단순한 컴포넌트들의 조합**
2. **Container는 로직, Presentational은 UI**
3. **인터페이스로 약속을 명확히**
4. **이벤트 전파를 제대로 제어하자**

이제 어떤 복잡한 기능이 와도 작은 컴포넌트들로 나누어 해결할 수 있다! 🎉
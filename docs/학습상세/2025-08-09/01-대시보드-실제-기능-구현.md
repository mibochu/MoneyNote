# 대시보드 실제 기능 구현

## 🎯 학습 목표
UI 목업 상태의 대시보드를 실제 ExpenseContext 데이터와 연동하여 동작하는 실무 수준 대시보드로 구현한다.

## 💡 왜 이걸 했는가?

### 문제 상황
- 기존 대시보드는 모든 값이 하드코딩된 `₩0`으로 표시
- 실제 지출 데이터가 있어도 대시보드에 반영되지 않음
- 사용자가 지출을 입력해도 대시보드 통계가 변하지 않는 문제

### 해결 필요성
실제 사용 가능한 가계부 앱이 되려면 대시보드가 실시간으로 데이터를 반영해야 함

## 🔧 어떻게 했는가?

### 1단계: Context 연동 및 컴포넌트 구조 개선

#### ❌ Before (하드코딩된 UI)
```typescript
const Dashboard: React.FC = () => {
  return (
    <Box>
      {/* 모든 값이 하드코딩 */}
      <Typography variant="h4" color="primary">
        ₩0  {/* 항상 0원 */}
      </Typography>
    </Box>
  );
};
```

#### ✅ After (2025년 패턴 + 실제 데이터)
```typescript
function Dashboard() {
  const expenseContext = useContext(ExpenseContext);
  
  if (!expenseContext) {
    throw new Error('Dashboard must be used within ExpenseProvider');
  }

  const { state } = expenseContext;

  // 실제 데이터로 통계 계산
  const monthlyStats = useMemo(() => {
    // 복잡한 계산 로직...
  }, [state.expenses]);

  return (
    <Box>
      <Typography variant="h4" color="primary">
        {formatCurrency(monthlyStats.income)}  {/* 실제 계산된 값 */}
      </Typography>
    </Box>
  );
}
```

**🎯 개선점:**
- ✅ React.FC → function 선언으로 2025년 패턴 적용
- ✅ ExpenseContext 연동으로 실제 데이터 활용
- ✅ 타입 안전한 Context 사용 (에러 처리 포함)

### 2단계: 복잡한 월별 통계 계산 로직 구현

#### 핵심 로직: 현재 월 데이터 필터링
```typescript
const monthlyStats = useMemo(() => {
  const now = new Date();
  const currentMonth = now.getMonth();
  const currentYear = now.getFullYear();

  // 현재 월의 지출만 필터링
  const currentMonthExpenses = state.expenses.filter(expense => {
    const expenseDate = new Date(expense.date);
    return expenseDate.getMonth() === currentMonth && 
           expenseDate.getFullYear() === currentYear;
  });

  // 카테고리별 분류 및 집계
  const income = currentMonthExpenses
    .filter(expense => expense.category === '수입')
    .reduce((sum, expense) => sum + expense.amount, 0);

  const savings = currentMonthExpenses
    .filter(expense => expense.category === '저축')
    .reduce((sum, expense) => sum + expense.amount, 0);

  const totalExpenses = currentMonthExpenses
    .filter(expense => expense.category !== '수입' && expense.category !== '저축')
    .reduce((sum, expense) => sum + expense.amount, 0);

  // 예산 잔액 = 수입 - 지출 - 저축
  const budgetBalance = income - totalExpenses - savings;

  return {
    income,
    totalExpenses,  
    savings,
    budgetBalance,
    currentMonthExpenses
  };
}, [state.expenses]);
```

**🔍 핵심 개념들:**

1. **날짜 필터링**: `getMonth()`와 `getFullYear()` 활용
2. **카테고리별 분류**: 수입/저축/일반지출 구분
3. **배열 메서드 체이닝**: `filter()` + `reduce()` 조합
4. **useMemo 최적화**: `state.expenses` 변경시에만 재계산

### 3단계: 국제화 API를 활용한 통화 포맷팅

#### 전문적인 금액 표시
```typescript
const formatCurrency = (amount: number): string => {
  return new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: 'KRW'
  }).format(amount);
};

// 사용 예시
{formatCurrency(monthlyStats.income)}  // ₩50,000
```

**💡 왜 Intl API를 사용했나?**
- 한국어 숫자 포맷팅 (쉼표 구분)
- 통화 기호 자동 추가
- 국제 표준 API로 안정성 보장

### 4단계: 동적 UI 및 조건부 렌더링

#### 상태에 따른 색상 변경
```typescript
<Typography 
  variant="h4" 
  color={monthlyStats.budgetBalance >= 0 ? "info" : "error"}
>
  {formatCurrency(monthlyStats.budgetBalance)}
</Typography>
```

#### 데이터 존재 여부에 따른 조건부 표시
```typescript
{recentTransactions.length > 0 ? (
  <List sx={{ height: 300, overflow: 'auto', p: 0 }}>
    {recentTransactions.map((transaction, index) => (
      // 실제 거래 목록 표시
    ))}
  </List>
) : (
  <Box sx={{ /* 빈 상태 UI */ }}>
    <Typography color="text.secondary">
      거래 내역이 없습니다
    </Typography>
  </Box>
)}
```

### 5단계: 결제수단별 집계 고급 기능

#### 객체 동적 생성 및 정렬
```typescript
const paymentMethodStats = useMemo(() => {
  const paymentMethods: Record<string, number> = {};
  
  // 동적으로 결제수단별 합계 계산
  monthlyStats.currentMonthExpenses
    .filter(expense => expense.category !== '수입' && expense.category !== '저축')
    .forEach(expense => {
      const method = expense.paymentMethod || '미지정';
      paymentMethods[method] = (paymentMethods[method] || 0) + expense.amount;
    });

  // 금액 순으로 정렬하여 상위 4개만 반환
  return Object.entries(paymentMethods)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 4);
}, [monthlyStats.currentMonthExpenses]);
```

**🎯 고급 개념들:**
- `Record<string, number>` 타입으로 동적 객체 타입 정의
- `Object.entries()` + 구조분해할당으로 배열 변환
- 커스텀 정렬 함수로 금액 기준 내림차순 정렬

### 6단계: 반응형 그리드 레이아웃

#### Material-UI sx prop 활용
```typescript
<Box sx={{ 
  display: 'grid', 
  gridTemplateColumns: { 
    xs: '1fr',              // 모바일: 1열
    sm: '1fr 1fr',         // 태블릿: 2열  
    md: '1fr 1fr 1fr 1fr'  // 데스크톱: 4열
  },
  gap: 3
}}>
```

## 🎓 핵심 교훈

### 1. 실무 개발에서의 성능 최적화
단순한 예제에서는 useMemo가 "선택사항"으로 보였지만, 실제 복잡한 계산이 필요한 대시보드에서는 **필수**임을 깨달았다.

### 2. 사용자 경험을 위한 세심한 배려
- 데이터 없을 때의 빈 상태 UI
- 예산 초과시 빨간색으로 경고
- 백분율 표시로 직관적인 정보 제공

### 3. 타입 안전성의 실제적 가치
Context를 사용할 때 에러 처리를 통한 타입 안전성 확보가 런타임 에러를 방지하는 실제적 효과가 있음을 체험했다.

### 4. 2025년 패턴의 실제 장점
function 선언과 최신 패턴들이 단순한 스타일 변경이 아니라 실제로 코드의 가독성과 유지보수성을 크게 향상시킨다는 것을 확인했다.

## 📊 성능 개선 효과

### Before vs After 비교
| 항목 | Before | After | 개선도 |
|------|--------|-------|---------|
| 데이터 반영 | 없음 | 실시간 | 🚀 완전 |
| 계산 성능 | N/A | 최적화됨 | ⚡ 효율적 |
| 사용자 경험 | 정적 | 동적/반응형 | 💫 대폭 향상 |
| 코드 품질 | 기본 | 실무 수준 | 📈 고급 |

## 🔄 다음 단계

### 추가 구현 가능한 기능들
1. **차트 시각화**: Chart.js 통합으로 원형차트, 막대그래프 추가
2. **필터링 옵션**: 월별/연도별 통계 전환 기능
3. **드릴다운**: 카테고리 클릭시 상세 내역 보기
4. **비교 분석**: 전월 대비 증감률 표시

### 학습 연결고리
- **커스텀 훅**: 대시보드 로직을 `useDashboardStats()` 훅으로 분리
- **성능 모니터링**: React DevTools Profiler로 최적화 효과 측정
- **테스팅**: 복잡한 계산 로직에 대한 단위 테스트 작성

---

**학습 시간**: 2시간 (구현 1.5h + 분석 0.5h)
**난이도**: ⚡ 고급 - 실무 수준 복잡도
**성취도**: ⭐⭐⭐⭐⭐ 완벽한 실무 수준 대시보드 구현! 🎯

이제 MoneyNote는 정말로 "사용할 수 있는" 가계부 앱이 되었습니다! 🚀✨
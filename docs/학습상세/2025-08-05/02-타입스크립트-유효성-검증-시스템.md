# íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ìœ íš¨ì„± ê²€ì¦ ì‹œìŠ¤í…œ

## ğŸ¯ í•™ìŠµ ëª©í‘œ
TypeScriptì˜ íƒ€ì… ì‹œìŠ¤í…œì„ í™œìš©í•˜ì—¬ ì•ˆì „í•˜ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ìœ íš¨ì„± ê²€ì¦ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•œë‹¤.

## ğŸ¤” ì™œ TypeScriptë¡œ ê²€ì¦ ì‹œìŠ¤í…œì„ ë§Œë“¤ê¹Œ?

### JavaScriptì˜ í•œê³„
ê¸°ì¡´ JavaScriptë¡œ ê²€ì¦ì„ êµ¬í˜„í•˜ë©´:

```javascript
// ì–´ë–¤ í•„ë“œë¥¼ ê²€ì¦í•˜ëŠ”ì§€ ë¶ˆëª…í™•
function validateForm(data) {
  const errors = {};
  
  if (!data.amount) {
    errors.amount = 'ê¸ˆì•¡ì„ ì…ë ¥í•˜ì„¸ìš”';
  }
  
  // amountê°€ ìˆ«ìì¸ì§€ í™•ì¸ ëª»í•¨
  // ì˜¤íƒ€ê°€ ìˆì–´ë„ ëŸ°íƒ€ì„ì—ì„œë§Œ ë°œê²¬
  if (data.amont < 0) { // ì˜¤íƒ€!
    errors.amount = 'ì–‘ìˆ˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”';
  }
  
  return errors;
}
```

**ë¬¸ì œì ë“¤:**
- ê²€ì¦í•  í•„ë“œê°€ ë¬´ì—‡ì¸ì§€ ëª…í™•í•˜ì§€ ì•ŠìŒ
- ë°ì´í„° íƒ€ì…ì„ ë³´ì¥í•  ìˆ˜ ì—†ìŒ
- ì˜¤íƒ€ë‚˜ ì˜ëª»ëœ í•„ë“œ ì ‘ê·¼ì„ ì»´íŒŒì¼ íƒ€ì„ì— ì°¾ì„ ìˆ˜ ì—†ìŒ
- ì¬ì‚¬ìš©í•˜ê¸° ì–´ë ¤ìš´ êµ¬ì¡°

## ğŸ—ï¸ TypeScript ê¸°ë°˜ ê²€ì¦ ì‹œìŠ¤í…œ ì„¤ê³„

### 1ë‹¨ê³„: ê¸°ë³¸ íƒ€ì… ì •ì˜
ë¨¼ì € ê²€ì¦í•  ë°ì´í„°ì˜ íƒ€ì…ì„ ì •ì˜í•©ë‹ˆë‹¤:

```typescript
interface ExpenseFormData {
  amount: number;
  description: string;
  category: string;
  subcategory: string;
  paymentMethod: PaymentMethod;
  tags: string[];
  isFixed: boolean;
  date: Date;
}

type PaymentMethod = 'cash' | 'card' | 'bank' | 'digital' | 'other';
```

### 2ë‹¨ê³„: ê²€ì¦ ê²°ê³¼ íƒ€ì… ì •ì˜
ê²€ì¦ ê²°ê³¼ì˜ êµ¬ì¡°ë¥¼ ëª…í™•íˆ ì •ì˜í•©ë‹ˆë‹¤:

```typescript
// ê²€ì¦ ê²°ê³¼ ì¸í„°í˜ì´ìŠ¤
interface ValidationResult {
  isValid: boolean;
  errors: Partial<Record<keyof ExpenseFormData, string>>;
}

// ê²€ì¦ ê·œì¹™ ì¸í„°í˜ì´ìŠ¤
interface ValidationRules {
  amount?: {
    min?: number;
    max?: number;
    required?: boolean;
  };
  description?: {
    minLength?: number;
    maxLength?: number;
    required?: boolean;
  };
  // ë‹¤ë¥¸ í•„ë“œë“¤...
}
```

**íƒ€ì… ì‹œìŠ¤í…œì˜ ì¥ì :**
- `keyof ExpenseFormData`ë¡œ í•„ë“œëª… ì˜¤íƒ€ ë°©ì§€
- `Partial<Record<...>>`ë¡œ ì„ íƒì  ì—ëŸ¬ í•„ë“œ í‘œí˜„
- IDEì—ì„œ ìë™ì™„ì„± ì§€ì›

### 3ë‹¨ê³„: ê°œë³„ í•„ë“œ ê²€ì¦ í•¨ìˆ˜
ê° í•„ë“œë³„ë¡œ íƒ€ì… ì•ˆì „í•œ ê²€ì¦ í•¨ìˆ˜ë¥¼ ë§Œë“­ë‹ˆë‹¤:

```typescript
// ê¸ˆì•¡ ê²€ì¦ í•¨ìˆ˜
export const validateAmount = (
  amount: number, 
  rules: ValidationRules['amount'] = {}
): string | null => {
  const { min = 0.01, max = 10000000, required = true } = rules;

  // TypeScriptê°€ amountê°€ numberì„ì„ ë³´ì¥
  if (required && (amount === null || amount === undefined)) {
    return 'ê¸ˆì•¡ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.';
  }

  if (amount <= 0) {
    return 'ê¸ˆì•¡ì€ 0ë³´ë‹¤ í° ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤.';
  }

  if (amount < min) {
    return `ê¸ˆì•¡ì€ ìµœì†Œ ${min.toLocaleString('ko-KR')}ì› ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.`;
  }

  if (amount > max) {
    return `ê¸ˆì•¡ì€ ìµœëŒ€ ${max.toLocaleString('ko-KR')}ì› ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.`;
  }

  return null; // ê²€ì¦ í†µê³¼
};

// ì„¤ëª… ê²€ì¦ í•¨ìˆ˜
export const validateDescription = (
  description: string, 
  rules: ValidationRules['description'] = {}
): string | null => {
  const { minLength = 1, maxLength = 200, required = true } = rules;

  if (required && !description?.trim()) {
    return 'ì§€ì¶œ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.';
  }

  if (description && description.trim().length < minLength) {
    return `ì§€ì¶œ ë‚´ìš©ì€ ìµœì†Œ ${minLength}ì ì´ìƒ ì…ë ¥í•´ì£¼ì„¸ìš”.`;
  }

  if (description && description.length > maxLength) {
    return `ì§€ì¶œ ë‚´ìš©ì€ ìµœëŒ€ ${maxLength}ìê¹Œì§€ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.`;
  }

  return null;
};
```

### 4ë‹¨ê³„: ì œë„¤ë¦­ì„ í™œìš©í•œ ë²”ìš© ê²€ì¦ í•¨ìˆ˜
ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ê²€ì¦ í•¨ìˆ˜ë¥¼ ë§Œë“­ë‹ˆë‹¤:

```typescript
// ì œë„¤ë¦­ í•„ë“œ ê²€ì¦ í•¨ìˆ˜
export const validateField = <T extends Record<string, any>>(
  fieldName: keyof T,
  value: T[keyof T],
  rules: ValidationRules = {}
): string | null => {
  switch (fieldName) {
    case 'amount':
      return validateAmount(value as number, rules.amount);
    case 'description':
      return validateDescription(value as string, rules.description);
    case 'category':
      return validateCategory(value as string, rules.category);
    case 'paymentMethod':
      return validatePaymentMethod(value as PaymentMethod, rules.paymentMethod);
    case 'date':
      return validateDate(value as Date, rules.date);
    default:
      return null;
  }
};
```

### 5ë‹¨ê³„: ì „ì²´ í¼ ê²€ì¦ í•¨ìˆ˜
ëª¨ë“  í•„ë“œë¥¼ í•œë²ˆì— ê²€ì¦í•˜ëŠ” í•¨ìˆ˜:

```typescript
export const validateExpenseForm = (
  formData: ExpenseFormData, 
  customRules: ValidationRules = {}
): ValidationResult => {
  // ê¸°ë³¸ ê·œì¹™ê³¼ ì»¤ìŠ¤í…€ ê·œì¹™ ë³‘í•©
  const rules = { ...DEFAULT_VALIDATION_RULES, ...customRules };
  const errors: Partial<Record<keyof ExpenseFormData, string>> = {};

  // ê° í•„ë“œ ê²€ì¦
  const amountError = validateAmount(formData.amount, rules.amount);
  if (amountError) errors.amount = amountError;

  const descriptionError = validateDescription(formData.description, rules.description);
  if (descriptionError) errors.description = descriptionError;

  const categoryError = validateCategory(formData.category, rules.category);
  if (categoryError) errors.category = categoryError;

  const paymentMethodError = validatePaymentMethod(formData.paymentMethod, rules.paymentMethod);
  if (paymentMethodError) errors.paymentMethod = paymentMethodError;

  const dateError = validateDate(formData.date, rules.date);
  if (dateError) errors.date = dateError;

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};
```

## ğŸ”§ ê³ ê¸‰ TypeScript íŒ¨í„´ í™œìš©

### 1. ì¡°ê±´ë¶€ íƒ€ì… (Conditional Types)
ê²€ì¦ ê·œì¹™ì„ í•„ë“œ íƒ€ì…ì— ë”°ë¼ ìë™ìœ¼ë¡œ ê²°ì •:

```typescript
type ValidationRule<T> = T extends number
  ? { min?: number; max?: number; required?: boolean }
  : T extends string
  ? { minLength?: number; maxLength?: number; required?: boolean }
  : T extends Date
  ? { minDate?: Date; maxDate?: Date; required?: boolean }
  : { required?: boolean };

// ì‚¬ìš© ì˜ˆì‹œ
type AmountRule = ValidationRule<number>; // { min?: number; max?: number; required?: boolean }
type DescriptionRule = ValidationRule<string>; // { minLength?: number; maxLength?: number; required?: boolean }
```

### 2. ë§¤í•‘ëœ íƒ€ì… (Mapped Types)
í¼ ë°ì´í„°ì˜ ê° í•„ë“œì— ëŒ€ì‘í•˜ëŠ” ê²€ì¦ ê·œì¹™ì„ ìë™ ìƒì„±:

```typescript
type FormValidationRules<T> = {
  [K in keyof T]?: ValidationRule<T[K]>;
};

// ExpenseFormDataì˜ ëª¨ë“  í•„ë“œì— ëŒ€í•œ ê²€ì¦ ê·œì¹™
type ExpenseValidationRules = FormValidationRules<ExpenseFormData>;
```

### 3. ìœ í‹¸ë¦¬í‹° íƒ€ì… í™œìš©
ê¸°ì¡´ íƒ€ì…ì„ ë³€í˜•í•˜ì—¬ ìƒˆë¡œìš´ íƒ€ì… ìƒì„±:

```typescript
// í•„ìˆ˜ í•„ë“œë§Œ ì¶”ì¶œ
type RequiredFields<T> = {
  [K in keyof T]-?: T[K];
};

// ì„ íƒì  í•„ë“œë§Œ ì¶”ì¶œ
type OptionalFields<T> = {
  [K in keyof T]?: T[K];
};

// íŠ¹ì • í•„ë“œë§Œ ì„ íƒ
type PickFields<T, K extends keyof T> = Pick<T, K>;

// íŠ¹ì • í•„ë“œ ì œì™¸
type OmitFields<T, K extends keyof T> = Omit<T, K>;

// ì‚¬ìš© ì˜ˆì‹œ
type BasicExpenseData = PickFields<ExpenseFormData, 'amount' | 'description' | 'date'>;
type ExpenseDataWithoutTags = OmitFields<ExpenseFormData, 'tags'>;
```

## ğŸ¨ ì‹¤ì œ ì ìš© ì‚¬ë¡€

### 1. ì»´í¬ë„ŒíŠ¸ì—ì„œì˜ í™œìš©
```typescript
const ExpenseForm: React.FC<ExpenseFormProps> = ({ formData, onFieldChange }) => {
  const [errors, setErrors] = useState<Partial<Record<keyof ExpenseFormData, string>>>({});

  const handleAmountChange = (amount: number) => {
    // íƒ€ì… ì•ˆì „í•œ í•„ë“œ ì—…ë°ì´íŠ¸
    onFieldChange('amount', amount);
    
    // ì‹¤ì‹œê°„ ê²€ì¦
    const error = validateField('amount', amount);
    setErrors(prev => ({ ...prev, amount: error || undefined }));
  };

  // TypeScriptê°€ formData.amountê°€ numberì„ì„ ë³´ì¥
  return (
    <CurrencyInput
      value={formData.amount}
      onAmountChange={handleAmountChange}
      error={!!errors.amount}
      helperText={errors.amount}
    />
  );
};
```

### 2. ì»¤ìŠ¤í…€ Hookìœ¼ë¡œ ê²€ì¦ ë¡œì§ ì¬ì‚¬ìš©
```typescript
const useFormValidation = <T extends Record<string, any>>(
  initialData: T,
  validationRules: ValidationRules
) => {
  const [data, setData] = useState<T>(initialData);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});

  const validateField = useCallback((field: keyof T, value: T[keyof T]) => {
    const error = validateField(field, value, validationRules);
    setErrors(prev => ({ ...prev, [field]: error || undefined }));
    return !error;
  }, [validationRules]);

  const updateField = useCallback((field: keyof T, value: T[keyof T]) => {
    setData(prev => ({ ...prev, [field]: value }));
    validateField(field, value);
  }, [validateField]);

  const validateAll = useCallback(() => {
    const validation = validateExpenseForm(data as ExpenseFormData, validationRules);
    setErrors(validation.errors);
    return validation.isValid;
  }, [data, validationRules]);

  return {
    data,
    errors,
    updateField,
    validateField,
    validateAll,
    isValid: Object.keys(errors).length === 0
  };
};
```

### 3. ë‹¤ì–‘í•œ ê²€ì¦ ì‹œë‚˜ë¦¬ì˜¤ ì§€ì›
```typescript
// ê¸°ë³¸ ê°œì¸ ì§€ì¶œ ê²€ì¦
const personalExpenseRules: ValidationRules = {
  amount: { min: 100, max: 5000000 },
  description: { minLength: 1, maxLength: 100 }
};

// ì‚¬ì—…ë¹„ ê²€ì¦ (ë” ì—„ê²©í•¨)
const businessExpenseRules: ValidationRules = {
  amount: { min: 1000, max: 50000000 },
  description: { minLength: 5, maxLength: 300 } // ë” ìì„¸í•œ ì„¤ëª… í•„ìš”
};

// ê³ ì •ë¹„ ê²€ì¦
const fixedExpenseRules: ValidationRules = {
  amount: { min: 10000, max: 2000000 },
  description: { minLength: 3, maxLength: 50 }
};

// ì‚¬ìš©
const validatePersonalExpense = (data: ExpenseFormData) => 
  validateExpenseForm(data, personalExpenseRules);

const validateBusinessExpense = (data: ExpenseFormData) => 
  validateExpenseForm(data, businessExpenseRules);
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì¹œí™”ì  ì„¤ê³„

### ìˆœìˆ˜ í•¨ìˆ˜ë¡œ ê²€ì¦ ë¡œì§ ë¶„ë¦¬
```typescript
describe('ExpenseValidators', () => {
  describe('validateAmount', () => {
    test('ì–‘ìˆ˜ ê²€ì¦', () => {
      expect(validateAmount(-100)).toBe('ê¸ˆì•¡ì€ 0ë³´ë‹¤ í° ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤.');
      expect(validateAmount(0)).toBe('ê¸ˆì•¡ì€ 0ë³´ë‹¤ í° ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤.');
      expect(validateAmount(1000)).toBe(null);
    });

    test('ìµœì†Ÿê°’ ê²€ì¦', () => {
      const result = validateAmount(50, { min: 100 });
      expect(result).toBe('ê¸ˆì•¡ì€ ìµœì†Œ 100ì› ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.');
    });

    test('ìµœëŒ“ê°’ ê²€ì¦', () => {
      const result = validateAmount(15000000, { max: 10000000 });
      expect(result).toBe('ê¸ˆì•¡ì€ ìµœëŒ€ 10,000,000ì› ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.');
    });
  });

  describe('validateExpenseForm', () => {
    test('ìœ íš¨í•œ ë°ì´í„°ì¸ ê²½ìš°', () => {
      const validData: ExpenseFormData = {
        amount: 1000,
        description: 'ì ì‹¬ì‹ì‚¬',
        category: 'food',
        subcategory: 'restaurant',
        paymentMethod: 'card',
        tags: ['ì™¸ì‹'],
        isFixed: false,
        date: new Date()
      };

      const result = validateExpenseForm(validData);
      expect(result.isValid).toBe(true);
      expect(result.errors).toEqual({});
    });

    test('ì—¬ëŸ¬ í•„ë“œì— ì—ëŸ¬ê°€ ìˆëŠ” ê²½ìš°', () => {
      const invalidData: ExpenseFormData = {
        amount: -100,
        description: '',
        category: '',
        // ... ë‹¤ë¥¸ í•„ë“œë“¤
      };

      const result = validateExpenseForm(invalidData);
      expect(result.isValid).toBe(false);
      expect(result.errors.amount).toBeDefined();
      expect(result.errors.description).toBeDefined();
      expect(result.errors.category).toBeDefined();
    });
  });
});
```

## ğŸ“Š TypeScript ê²€ì¦ ì‹œìŠ¤í…œì˜ ì¥ì 

### ê°œë°œ ì‹œì  ì´ì 
1. **ì»´íŒŒì¼ íƒ€ì„ ì—ëŸ¬ ê°ì§€**: ì˜¤íƒ€ë‚˜ ì˜ëª»ëœ íƒ€ì… ì‚¬ìš©ì„ ë¯¸ë¦¬ ë°œê²¬
2. **ìë™ì™„ì„± ì§€ì›**: IDEì—ì„œ í•„ë“œëª…ê³¼ ê·œì¹™ì„ ìë™ìœ¼ë¡œ ì œì•ˆ
3. **ë¦¬íŒ©í† ë§ ì•ˆì „ì„±**: í•„ë“œëª… ë³€ê²½ ì‹œ ëª¨ë“  ê´€ë ¨ ì½”ë“œ ìë™ ì—…ë°ì´íŠ¸

### ëŸ°íƒ€ì„ ì´ì 
1. **íƒ€ì… ì•ˆì „ì„±**: ì˜ëª»ëœ íƒ€ì…ì˜ ë°ì´í„°ë¡œ ê²€ì¦ í•¨ìˆ˜ í˜¸ì¶œ ë°©ì§€
2. **ì˜ˆì¸¡ ê°€ëŠ¥í•œ ë™ì‘**: í•¨ìˆ˜ì˜ ì…ë ¥ê³¼ ì¶œë ¥ì´ ëª…í™•íˆ ì •ì˜ë¨
3. **ì—ëŸ¬ ì¶”ì  ìš©ì´ì„±**: íƒ€ì… ì •ë³´ë¡œ ë””ë²„ê¹…ì´ ì‰¬ì›Œì§

### ìœ ì§€ë³´ìˆ˜ì„±
1. **ëª…í™•í•œ ê³„ì•½**: ì¸í„°í˜ì´ìŠ¤ë¡œ ê¸°ëŒ€í•˜ëŠ” ë°ì´í„° êµ¬ì¡° ëª…ì‹œ
2. **ì¬ì‚¬ìš©ì„±**: ì œë„¤ë¦­ê³¼ ìœ í‹¸ë¦¬í‹° íƒ€ì…ìœ¼ë¡œ ë‹¤ì–‘í•œ ìƒí™©ì— í™œìš©
3. **í™•ì¥ì„±**: ìƒˆë¡œìš´ í•„ë“œë‚˜ ê·œì¹™ ì¶”ê°€ê°€ ì•ˆì „í•˜ê³  ì‰¬ì›€

## ğŸ¯ í•µì‹¬ ë°°ìš´ ì 

1. **íƒ€ì… ìš°ì„  ì„¤ê³„**: ë°ì´í„° êµ¬ì¡°ë¥¼ ë¨¼ì € ì •ì˜í•˜ê³  ë¡œì§ êµ¬í˜„
2. **ì œë„¤ë¦­ í™œìš©**: ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ê²€ì¦ ì‹œìŠ¤í…œ êµ¬ì¶•
3. **ìœ í‹¸ë¦¬í‹° íƒ€ì…**: Pick, Omit, Partial ë“±ìœ¼ë¡œ íƒ€ì… ì¡°ì‘
4. **ì»´íŒŒì¼ íƒ€ì„ ì•ˆì „ì„±**: ëŸ°íƒ€ì„ ì—ëŸ¬ë¥¼ ì»´íŒŒì¼ íƒ€ì„ì— ë°©ì§€

TypeScriptì˜ íƒ€ì… ì‹œìŠ¤í…œì„ ì œëŒ€ë¡œ í™œìš©í•˜ë©´, ë” ì•ˆì „í•˜ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ìš´ ê²€ì¦ ì‹œìŠ¤í…œì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€
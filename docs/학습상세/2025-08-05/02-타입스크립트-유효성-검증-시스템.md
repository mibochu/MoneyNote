# 타입스크립트 유효성 검증 시스템

## 🎯 학습 목표
TypeScript의 타입 시스템을 활용하여 안전하고 재사용 가능한 유효성 검증 시스템을 구축한다.

## 🤔 왜 TypeScript로 검증 시스템을 만들까?

### JavaScript의 한계
기존 JavaScript로 검증을 구현하면:

```javascript
// 어떤 필드를 검증하는지 불명확
function validateForm(data) {
  const errors = {};
  
  if (!data.amount) {
    errors.amount = '금액을 입력하세요';
  }
  
  // amount가 숫자인지 확인 못함
  // 오타가 있어도 런타임에서만 발견
  if (data.amont < 0) { // 오타!
    errors.amount = '양수를 입력하세요';
  }
  
  return errors;
}
```

**문제점들:**
- 검증할 필드가 무엇인지 명확하지 않음
- 데이터 타입을 보장할 수 없음
- 오타나 잘못된 필드 접근을 컴파일 타임에 찾을 수 없음
- 재사용하기 어려운 구조

## 🏗️ TypeScript 기반 검증 시스템 설계

### 1단계: 기본 타입 정의
먼저 검증할 데이터의 타입을 정의합니다:

```typescript
interface ExpenseFormData {
  amount: number;
  description: string;
  category: string;
  subcategory: string;
  paymentMethod: PaymentMethod;
  tags: string[];
  isFixed: boolean;
  date: Date;
}

type PaymentMethod = 'cash' | 'card' | 'bank' | 'digital' | 'other';
```

### 2단계: 검증 결과 타입 정의
검증 결과의 구조를 명확히 정의합니다:

```typescript
// 검증 결과 인터페이스
interface ValidationResult {
  isValid: boolean;
  errors: Partial<Record<keyof ExpenseFormData, string>>;
}

// 검증 규칙 인터페이스
interface ValidationRules {
  amount?: {
    min?: number;
    max?: number;
    required?: boolean;
  };
  description?: {
    minLength?: number;
    maxLength?: number;
    required?: boolean;
  };
  // 다른 필드들...
}
```

**타입 시스템의 장점:**
- `keyof ExpenseFormData`로 필드명 오타 방지
- `Partial<Record<...>>`로 선택적 에러 필드 표현
- IDE에서 자동완성 지원

### 3단계: 개별 필드 검증 함수
각 필드별로 타입 안전한 검증 함수를 만듭니다:

```typescript
// 금액 검증 함수
export const validateAmount = (
  amount: number, 
  rules: ValidationRules['amount'] = {}
): string | null => {
  const { min = 0.01, max = 10000000, required = true } = rules;

  // TypeScript가 amount가 number임을 보장
  if (required && (amount === null || amount === undefined)) {
    return '금액을 입력해주세요.';
  }

  if (amount <= 0) {
    return '금액은 0보다 큰 값이어야 합니다.';
  }

  if (amount < min) {
    return `금액은 최소 ${min.toLocaleString('ko-KR')}원 이상이어야 합니다.`;
  }

  if (amount > max) {
    return `금액은 최대 ${max.toLocaleString('ko-KR')}원 이하여야 합니다.`;
  }

  return null; // 검증 통과
};

// 설명 검증 함수
export const validateDescription = (
  description: string, 
  rules: ValidationRules['description'] = {}
): string | null => {
  const { minLength = 1, maxLength = 200, required = true } = rules;

  if (required && !description?.trim()) {
    return '지출 내용을 입력해주세요.';
  }

  if (description && description.trim().length < minLength) {
    return `지출 내용은 최소 ${minLength}자 이상 입력해주세요.`;
  }

  if (description && description.length > maxLength) {
    return `지출 내용은 최대 ${maxLength}자까지 입력 가능합니다.`;
  }

  return null;
};
```

### 4단계: 제네릭을 활용한 범용 검증 함수
재사용 가능한 검증 함수를 만듭니다:

```typescript
// 제네릭 필드 검증 함수
export const validateField = <T extends Record<string, any>>(
  fieldName: keyof T,
  value: T[keyof T],
  rules: ValidationRules = {}
): string | null => {
  switch (fieldName) {
    case 'amount':
      return validateAmount(value as number, rules.amount);
    case 'description':
      return validateDescription(value as string, rules.description);
    case 'category':
      return validateCategory(value as string, rules.category);
    case 'paymentMethod':
      return validatePaymentMethod(value as PaymentMethod, rules.paymentMethod);
    case 'date':
      return validateDate(value as Date, rules.date);
    default:
      return null;
  }
};
```

### 5단계: 전체 폼 검증 함수
모든 필드를 한번에 검증하는 함수:

```typescript
export const validateExpenseForm = (
  formData: ExpenseFormData, 
  customRules: ValidationRules = {}
): ValidationResult => {
  // 기본 규칙과 커스텀 규칙 병합
  const rules = { ...DEFAULT_VALIDATION_RULES, ...customRules };
  const errors: Partial<Record<keyof ExpenseFormData, string>> = {};

  // 각 필드 검증
  const amountError = validateAmount(formData.amount, rules.amount);
  if (amountError) errors.amount = amountError;

  const descriptionError = validateDescription(formData.description, rules.description);
  if (descriptionError) errors.description = descriptionError;

  const categoryError = validateCategory(formData.category, rules.category);
  if (categoryError) errors.category = categoryError;

  const paymentMethodError = validatePaymentMethod(formData.paymentMethod, rules.paymentMethod);
  if (paymentMethodError) errors.paymentMethod = paymentMethodError;

  const dateError = validateDate(formData.date, rules.date);
  if (dateError) errors.date = dateError;

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};
```

## 🔧 고급 TypeScript 패턴 활용

### 1. 조건부 타입 (Conditional Types)
검증 규칙을 필드 타입에 따라 자동으로 결정:

```typescript
type ValidationRule<T> = T extends number
  ? { min?: number; max?: number; required?: boolean }
  : T extends string
  ? { minLength?: number; maxLength?: number; required?: boolean }
  : T extends Date
  ? { minDate?: Date; maxDate?: Date; required?: boolean }
  : { required?: boolean };

// 사용 예시
type AmountRule = ValidationRule<number>; // { min?: number; max?: number; required?: boolean }
type DescriptionRule = ValidationRule<string>; // { minLength?: number; maxLength?: number; required?: boolean }
```

### 2. 매핑된 타입 (Mapped Types)
폼 데이터의 각 필드에 대응하는 검증 규칙을 자동 생성:

```typescript
type FormValidationRules<T> = {
  [K in keyof T]?: ValidationRule<T[K]>;
};

// ExpenseFormData의 모든 필드에 대한 검증 규칙
type ExpenseValidationRules = FormValidationRules<ExpenseFormData>;
```

### 3. 유틸리티 타입 활용
기존 타입을 변형하여 새로운 타입 생성:

```typescript
// 필수 필드만 추출
type RequiredFields<T> = {
  [K in keyof T]-?: T[K];
};

// 선택적 필드만 추출
type OptionalFields<T> = {
  [K in keyof T]?: T[K];
};

// 특정 필드만 선택
type PickFields<T, K extends keyof T> = Pick<T, K>;

// 특정 필드 제외
type OmitFields<T, K extends keyof T> = Omit<T, K>;

// 사용 예시
type BasicExpenseData = PickFields<ExpenseFormData, 'amount' | 'description' | 'date'>;
type ExpenseDataWithoutTags = OmitFields<ExpenseFormData, 'tags'>;
```

## 🎨 실제 적용 사례

### 1. 컴포넌트에서의 활용
```typescript
const ExpenseForm: React.FC<ExpenseFormProps> = ({ formData, onFieldChange }) => {
  const [errors, setErrors] = useState<Partial<Record<keyof ExpenseFormData, string>>>({});

  const handleAmountChange = (amount: number) => {
    // 타입 안전한 필드 업데이트
    onFieldChange('amount', amount);
    
    // 실시간 검증
    const error = validateField('amount', amount);
    setErrors(prev => ({ ...prev, amount: error || undefined }));
  };

  // TypeScript가 formData.amount가 number임을 보장
  return (
    <CurrencyInput
      value={formData.amount}
      onAmountChange={handleAmountChange}
      error={!!errors.amount}
      helperText={errors.amount}
    />
  );
};
```

### 2. 커스텀 Hook으로 검증 로직 재사용
```typescript
const useFormValidation = <T extends Record<string, any>>(
  initialData: T,
  validationRules: ValidationRules
) => {
  const [data, setData] = useState<T>(initialData);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});

  const validateField = useCallback((field: keyof T, value: T[keyof T]) => {
    const error = validateField(field, value, validationRules);
    setErrors(prev => ({ ...prev, [field]: error || undefined }));
    return !error;
  }, [validationRules]);

  const updateField = useCallback((field: keyof T, value: T[keyof T]) => {
    setData(prev => ({ ...prev, [field]: value }));
    validateField(field, value);
  }, [validateField]);

  const validateAll = useCallback(() => {
    const validation = validateExpenseForm(data as ExpenseFormData, validationRules);
    setErrors(validation.errors);
    return validation.isValid;
  }, [data, validationRules]);

  return {
    data,
    errors,
    updateField,
    validateField,
    validateAll,
    isValid: Object.keys(errors).length === 0
  };
};
```

### 3. 다양한 검증 시나리오 지원
```typescript
// 기본 개인 지출 검증
const personalExpenseRules: ValidationRules = {
  amount: { min: 100, max: 5000000 },
  description: { minLength: 1, maxLength: 100 }
};

// 사업비 검증 (더 엄격함)
const businessExpenseRules: ValidationRules = {
  amount: { min: 1000, max: 50000000 },
  description: { minLength: 5, maxLength: 300 } // 더 자세한 설명 필요
};

// 고정비 검증
const fixedExpenseRules: ValidationRules = {
  amount: { min: 10000, max: 2000000 },
  description: { minLength: 3, maxLength: 50 }
};

// 사용
const validatePersonalExpense = (data: ExpenseFormData) => 
  validateExpenseForm(data, personalExpenseRules);

const validateBusinessExpense = (data: ExpenseFormData) => 
  validateExpenseForm(data, businessExpenseRules);
```

## 🧪 테스트 친화적 설계

### 순수 함수로 검증 로직 분리
```typescript
describe('ExpenseValidators', () => {
  describe('validateAmount', () => {
    test('양수 검증', () => {
      expect(validateAmount(-100)).toBe('금액은 0보다 큰 값이어야 합니다.');
      expect(validateAmount(0)).toBe('금액은 0보다 큰 값이어야 합니다.');
      expect(validateAmount(1000)).toBe(null);
    });

    test('최솟값 검증', () => {
      const result = validateAmount(50, { min: 100 });
      expect(result).toBe('금액은 최소 100원 이상이어야 합니다.');
    });

    test('최댓값 검증', () => {
      const result = validateAmount(15000000, { max: 10000000 });
      expect(result).toBe('금액은 최대 10,000,000원 이하여야 합니다.');
    });
  });

  describe('validateExpenseForm', () => {
    test('유효한 데이터인 경우', () => {
      const validData: ExpenseFormData = {
        amount: 1000,
        description: '점심식사',
        category: 'food',
        subcategory: 'restaurant',
        paymentMethod: 'card',
        tags: ['외식'],
        isFixed: false,
        date: new Date()
      };

      const result = validateExpenseForm(validData);
      expect(result.isValid).toBe(true);
      expect(result.errors).toEqual({});
    });

    test('여러 필드에 에러가 있는 경우', () => {
      const invalidData: ExpenseFormData = {
        amount: -100,
        description: '',
        category: '',
        // ... 다른 필드들
      };

      const result = validateExpenseForm(invalidData);
      expect(result.isValid).toBe(false);
      expect(result.errors.amount).toBeDefined();
      expect(result.errors.description).toBeDefined();
      expect(result.errors.category).toBeDefined();
    });
  });
});
```

## 📊 TypeScript 검증 시스템의 장점

### 개발 시점 이점
1. **컴파일 타임 에러 감지**: 오타나 잘못된 타입 사용을 미리 발견
2. **자동완성 지원**: IDE에서 필드명과 규칙을 자동으로 제안
3. **리팩토링 안전성**: 필드명 변경 시 모든 관련 코드 자동 업데이트

### 런타임 이점
1. **타입 안전성**: 잘못된 타입의 데이터로 검증 함수 호출 방지
2. **예측 가능한 동작**: 함수의 입력과 출력이 명확히 정의됨
3. **에러 추적 용이성**: 타입 정보로 디버깅이 쉬워짐

### 유지보수성
1. **명확한 계약**: 인터페이스로 기대하는 데이터 구조 명시
2. **재사용성**: 제네릭과 유틸리티 타입으로 다양한 상황에 활용
3. **확장성**: 새로운 필드나 규칙 추가가 안전하고 쉬움

## 🎯 핵심 배운 점

1. **타입 우선 설계**: 데이터 구조를 먼저 정의하고 로직 구현
2. **제네릭 활용**: 재사용 가능한 검증 시스템 구축
3. **유틸리티 타입**: Pick, Omit, Partial 등으로 타입 조작
4. **컴파일 타임 안전성**: 런타임 에러를 컴파일 타임에 방지

TypeScript의 타입 시스템을 제대로 활용하면, 더 안전하고 유지보수하기 쉬운 검증 시스템을 만들 수 있습니다! 🚀
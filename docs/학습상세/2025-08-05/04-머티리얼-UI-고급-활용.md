# 머티리얼-UI 고급 활용

## 🎯 학습 목표
Material-UI의 고급 컴포넌트들을 활용하여 사용자 경험을 극대화하는 인터페이스를 구현한다.

## 💡 왜 Material-UI 고급 기능이 필요한가?

### 기본적인 사용의 한계
초보자는 보통 이렇게 사용합니다:

```typescript
// 단순한 버튼 사용
<Button onClick={handleClick}>저장</Button>

// 기본적인 입력 필드
<TextField 
  label="금액" 
  value={amount} 
  onChange={(e) => setAmount(e.target.value)} 
/>

// 단순한 알림
{showMessage && <div>저장되었습니다</div>}
```

**문제점들:**
- 사용자 피드백이 부족함
- 시각적 계층구조가 불분명함
- 상호작용이 직관적이지 않음
- 모바일 대응이 미흡함

## 🎨 고급 컴포넌트 활용 패턴

### 1. Dialog - 모달 인터페이스의 완성형

#### 기본 사용법을 넘어선 고급 활용
```typescript
const ExpenseFormDialog: React.FC<ExpenseFormDialogProps> = ({
  open,
  onClose,
  editMode = false,
  initialData
}) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const theme = useTheme();
  const fullScreen = useMediaQuery(theme.breakpoints.down('md'));

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="sm"
      fullWidth
      fullScreen={fullScreen} // 모바일에서는 전체화면
      // 백드롭 클릭 방지 (중요한 데이터 입력 중)
      disableEscapeKeyDown={isSubmitting}
      // 애니메이션 커스터마이징
      TransitionComponent={Slide}
      TransitionProps={{ direction: 'up' }}
    >
      {/* 헤더 영역 */}
      <DialogTitle 
        sx={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          alignItems: 'center',
          pb: 1 
        }}
      >
        <Box>
          <Typography variant="h6">
            {editMode ? '지출 수정' : '지출 추가'}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            {editMode ? '기존 지출 정보를 수정합니다' : '새로운 지출을 기록합니다'}
          </Typography>
        </Box>
        
        <IconButton
          onClick={onClose}
          disabled={isSubmitting}
          size="small"
          sx={{ ml: 2 }}
        >
          <CloseIcon />
        </IconButton>
      </DialogTitle>

      <Divider />

      {/* 컨텐츠 영역 - 스크롤 가능 */}
      <DialogContent sx={{ px: 3, py: 2 }}>
        <ExpenseFormContainer
          initialData={initialData}
          onSuccess={onClose}
          onCancel={onClose}
          isSubmitting={isSubmitting}
          onSubmittingChange={setIsSubmitting}
        />
      </DialogContent>

      {/* 푸터 영역 - 고정 */}
      <DialogActions sx={{ px: 3, py: 2, bgcolor: 'grey.50' }}>
        <Button 
          onClick={onClose} 
          disabled={isSubmitting}
          color="inherit"
        >
          취소
        </Button>
        <Button 
          variant="contained" 
          disabled={isSubmitting}
          startIcon={isSubmitting ? <CircularProgress size={20} /> : <SaveIcon />}
        >
          {isSubmitting ? '저장 중...' : '저장'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};
```

#### 고급 기능들
1. **반응형 fullScreen**: 모바일에서 전체화면 모달
2. **조건부 상호작용 차단**: 제출 중에는 ESC 키 무효화
3. **커스텀 트랜지션**: 아래에서 위로 슬라이드 애니메이션
4. **시각적 계층구조**: 헤더, 컨텐츠, 푸터의 명확한 구분

### 2. Snackbar - 사용자 피드백의 예술

#### 스마트한 알림 시스템 구축
```typescript
const useSmartNotification = () => {
  const [notifications, setNotifications] = useState<NotificationItem[]>([]);

  const addNotification = useCallback((notification: Omit<NotificationItem, 'id'>) => {
    const id = Date.now().toString();
    const newNotification: NotificationItem = {
      ...notification,
      id,
      timestamp: new Date()
    };

    setNotifications(prev => [...prev, newNotification]);

    // 자동 제거 (심각도에 따라 다른 시간)
    const duration = notification.severity === 'error' ? 8000 : 
                    notification.severity === 'warning' ? 6000 : 4000;

    setTimeout(() => {
      setNotifications(prev => prev.filter(n => n.id !== id));
    }, duration);
  }, []);

  return { notifications, addNotification };
};

// 스낵바 컴포넌트
const SmartSnackbar: React.FC = () => {
  const { notifications } = useSmartNotification();
  const [currentIndex, setCurrentIndex] = useState(0);

  // 여러 알림이 있을 때 순차적으로 표시
  useEffect(() => {
    if (notifications.length > 1) {
      const timer = setInterval(() => {
        setCurrentIndex(prev => (prev + 1) % notifications.length);
      }, 3000);
      
      return () => clearInterval(timer);
    }
  }, [notifications.length]);

  const currentNotification = notifications[currentIndex];

  if (!currentNotification) return null;

  return (
    <Snackbar
      open={true}
      anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      TransitionComponent={Grow}
      TransitionProps={{ timeout: 300 }}
    >
      <Alert 
        severity={currentNotification.severity}
        variant="filled"
        action={
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            {/* 여러 알림이 있을 때 페이지네이션 표시 */}
            {notifications.length > 1 && (
              <Typography variant="caption" sx={{ opacity: 0.8 }}>
                {currentIndex + 1}/{notifications.length}
              </Typography>
            )}
            <IconButton
              size="small"
              onClick={() => {/* 닫기 로직 */}}
              sx={{ color: 'inherit' }}
            >
              <CloseIcon fontSize="small" />
            </IconButton>
          </Box>
        }
      >
        <AlertTitle>{currentNotification.title}</AlertTitle>
        {currentNotification.message}
      </Alert>
    </Snackbar>
  );
};
```

### 3. Chip - 동적 태그 시스템의 구현

#### 인터랙티브 태그 입력 시스템
```typescript
const TagInput: React.FC<TagInputProps> = ({
  tags,
  onTagsChange,
  suggestions = [],
  placeholder = "태그를 입력하세요"
}) => {
  const [inputValue, setInputValue] = useState('');
  const [showSuggestions, setShowSuggestions] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  // 필터링된 제안 태그들
  const filteredSuggestions = suggestions.filter(
    suggestion => 
      suggestion.toLowerCase().includes(inputValue.toLowerCase()) &&
      !tags.includes(suggestion)
  );

  const handleKeyDown = (event: React.KeyboardEvent) => {
    switch (event.key) {
      case 'Enter':
      case ',':
        event.preventDefault();
        addTag(inputValue.trim());
        break;
      case 'Backspace':
        if (!inputValue && tags.length > 0) {
          // 빈 입력에서 백스페이스: 마지막 태그 삭제
          removeTag(tags[tags.length - 1]);
        }
        break;
      case 'ArrowDown':
        // 제안 목록으로 포커스 이동
        event.preventDefault();
        setShowSuggestions(true);
        break;
    }
  };

  const addTag = (tag: string) => {
    if (tag && !tags.includes(tag) && tags.length < 10) { // 최대 10개 제한
      onTagsChange([...tags, tag]);
      setInputValue('');
      setShowSuggestions(false);
    }
  };

  const removeTag = (tagToRemove: string) => {
    onTagsChange(tags.filter(tag => tag !== tagToRemove));
  };

  return (
    <Box>
      {/* 태그 표시 영역 */}
      <Box sx={{ mb: 1 }}>
        <Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
          {tags.map((tag, index) => (
            <Chip
              key={index}
              label={tag}
              onDelete={() => removeTag(tag)}
              size="small"
              color="primary"
              variant="outlined"
              // 태그별 색상 지정 (해시 기반)
              sx={{
                bgcolor: `hsl(${tag.split('').reduce((a, b) => a + b.charCodeAt(0), 0) % 360}, 70%, 95%)`,
                borderColor: `hsl(${tag.split('').reduce((a, b) => a + b.charCodeAt(0), 0) % 360}, 70%, 70%)`
              }}
              deleteIcon={
                <Tooltip title="태그 삭제">
                  <CloseIcon />
                </Tooltip>
              }
            />
          ))}
        </Stack>
      </Box>

      {/* 입력 영역 */}
      <Box sx={{ position: 'relative' }}>
        <TextField
          ref={inputRef}
          fullWidth
          size="small"
          placeholder={placeholder}
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyDown={handleKeyDown}
          onFocus={() => setShowSuggestions(true)}
          onBlur={() => setTimeout(() => setShowSuggestions(false), 200)}
          InputProps={{
            startAdornment: <LocalOfferIcon sx={{ mr: 1, color: 'text.secondary' }} />,
            endAdornment: (
              <Tooltip title="Enter 또는 쉼표로 태그 추가">
                <InfoIcon sx={{ color: 'text.secondary' }} />
              </Tooltip>
            )
          }}
          helperText={`${tags.length}/10 태그 | Enter 또는 쉼표로 추가`}
        />

        {/* 제안 목록 */}
        {showSuggestions && filteredSuggestions.length > 0 && (
          <Paper
            sx={{
              position: 'absolute',
              top: '100%',
              left: 0,
              right: 0,
              zIndex: 1000,
              maxHeight: 200,
              overflow: 'auto'
            }}
          >
            <List dense>
              {filteredSuggestions.slice(0, 5).map((suggestion, index) => (
                <ListItem
                  key={index}
                  button
                  onClick={() => addTag(suggestion)}
                >
                  <ListItemIcon>
                    <LocalOfferIcon fontSize="small" />
                  </ListItemIcon>
                  <ListItemText primary={suggestion} />
                </ListItem>
              ))}
            </List>
          </Paper>
        )}
      </Box>
    </Box>
  );
};
```

### 4. Stack과 Box - 레이아웃의 완성

#### 반응형 결제수단 선택 UI
```typescript
const PaymentMethodSelector: React.FC<PaymentMethodSelectorProps> = ({
  value,
  onChange,
  error
}) => {
  return (
    <Box>
      <Typography variant="body2" color="text.secondary" gutterBottom>
        결제수단 {error && <span style={{ color: 'red' }}>*</span>}
      </Typography>
      
      {/* 반응형 그리드 레이아웃 */}
      <Stack 
        direction="row" 
        spacing={1} 
        flexWrap="wrap" 
        useFlexGap
        sx={{
          // 모바일에서는 2열, 데스크톱에서는 5열
          '& > *': {
            flexBasis: { xs: 'calc(50% - 4px)', sm: 'calc(33.33% - 8px)', md: 'auto' }
          }
        }}
      >
        {PAYMENT_METHOD_OPTIONS.map(option => {
          const isSelected = value === option.value;
          const paymentInfo = PAYMENT_METHODS[option.value as PaymentMethod];
          
          return (
            <Button
              key={option.value}
              variant={isSelected ? "contained" : "outlined"}
              size="small"
              onClick={() => onChange(option.value as PaymentMethod)}
              sx={{
                minWidth: '80px',
                minHeight: '48px',
                textTransform: 'none',
                flexDirection: 'column',
                gap: 0.5,
                // 선택된 항목의 색상 테마
                ...(isSelected && {
                  bgcolor: paymentInfo.color,
                  '&:hover': {
                    bgcolor: paymentInfo.color,
                    filter: 'brightness(0.9)'
                  }
                }),
                // 선택되지 않은 항목의 테두리 색상
                ...(!isSelected && {
                  borderColor: paymentInfo.color,
                  color: paymentInfo.color,
                  '&:hover': {
                    borderColor: paymentInfo.color,
                    bgcolor: `${paymentInfo.color}10` // 10% 투명도
                  }
                })
              }}
            >
              <Typography variant="h6" component="span">
                {paymentInfo.icon}
              </Typography>
              <Typography variant="caption" component="span">
                {paymentInfo.label}
              </Typography>
            </Button>
          );
        })}
      </Stack>
      
      {error && (
        <Typography variant="caption" color="error" sx={{ mt: 1, display: 'block' }}>
          {error}
        </Typography>
      )}
    </Box>
  );
};
```

### 5. 고급 테마 커스터마이징

#### 일관된 디자인 시스템 구축
```typescript
const customTheme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    // 지출 관련 색상 팔레트
    expense: {
      food: '#FF9800',
      transport: '#4CAF50',
      entertainment: '#E91E63',
      healthcare: '#9C27B0',
      fixed: '#FF5722'
    }
  },
  components: {
    // Dialog 컴포넌트 기본 스타일
    MuiDialog: {
      styleOverrides: {
        paper: {
          borderRadius: 16,
          boxShadow: '0 8px 32px rgba(0,0,0,0.12)'
        }
      },
      defaultProps: {
        TransitionComponent: Slide,
        TransitionProps: { direction: 'up' }
      }
    },
    // Chip 컴포넌트 기본 스타일
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          fontWeight: 500
        },
        deleteIcon: {
          '&:hover': {
            color: 'error.main'
          }
        }
      }
    },
    // Button 컴포넌트 기본 스타일
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          textTransform: 'none',
          fontWeight: 600
        },
        containedPrimary: {
          boxShadow: '0 2px 8px rgba(25, 118, 210, 0.3)',
          '&:hover': {
            boxShadow: '0 4px 16px rgba(25, 118, 210, 0.4)'
          }
        }
      }
    }
  }
});
```

## 🎨 사용자 경험 향상 패턴

### 1. 피드백 시스템 구축
```typescript
const FeedbackSystem: React.FC = () => {
  const { addNotification } = useSmartNotification();
  
  const showSuccess = (message: string) => {
    addNotification({
      severity: 'success',
      title: '성공',
      message,
      action: null
    });
  };
  
  const showError = (message: string, action?: React.ReactNode) => {
    addNotification({
      severity: 'error',
      title: '오류',
      message,
      action: action || (
        <Button color="inherit" size="small">
          다시 시도
        </Button>
      )
    });
  };
  
  const showInfo = (message: string) => {
    addNotification({
      severity: 'info',
      title: '알림',
      message
    });
  };
  
  return { showSuccess, showError, showInfo };
};
```

### 2. 로딩 상태 관리
```typescript
const LoadingButton: React.FC<LoadingButtonProps> = ({
  loading,
  children,
  ...props
}) => {
  return (
    <Button
      {...props}
      disabled={loading || props.disabled}
      startIcon={loading ? <CircularProgress size={20} /> : props.startIcon}
    >
      {loading ? '처리 중...' : children}
    </Button>
  );
};
```

### 3. 접근성 고려사항
```typescript
const AccessibleDialog: React.FC<AccessibleDialogProps> = ({
  open,
  title,
  children,
  onClose
}) => {
  return (
    <Dialog
      open={open}
      onClose={onClose}
      aria-labelledby="dialog-title"
      aria-describedby="dialog-description"
      role="dialog"
    >
      <DialogTitle id="dialog-title">
        {title}
      </DialogTitle>
      <DialogContent id="dialog-description">
        {children}
      </DialogContent>
    </Dialog>
  );
};
```

## 📱 모바일 최적화 패턴

### 1. 터치 친화적 인터페이스
```typescript
const MobileFriendlyButton: React.FC = ({ children, ...props }) => {
  return (
    <Button
      {...props}
      sx={{
        minHeight: 48, // 터치 타겟 최소 크기
        px: 3,
        py: 1.5,
        ...props.sx
      }}
    >
      {children}
    </Button>
  );
};
```

### 2. 스와이프 제스처 지원
```typescript
const SwipeableExpenseItem: React.FC<SwipeableExpenseItemProps> = ({
  expense,
  onEdit,
  onDelete
}) => {
  return (
    <SwipeableListItem
      leftActions={[
        {
          icon: <EditIcon />,
          color: 'primary',
          action: () => onEdit(expense.id)
        }
      ]}
      rightActions={[
        {
          icon: <DeleteIcon />,
          color: 'error',
          action: () => onDelete(expense.id)
        }
      ]}
    >
      <ExpenseItem expense={expense} />
    </SwipeableListItem>
  );
};
```

## 🎯 실제 적용 효과

### Before (기본 사용)
```typescript
// 단순한 버튼과 알림
<Button onClick={handleSave}>저장</Button>
{message && <div>{message}</div>}
```

### After (고급 활용)
```typescript
// 상태를 고려한 버튼과 스마트 알림
<LoadingButton
  loading={isSubmitting}
  variant="contained"
  startIcon={<SaveIcon />}
  onClick={handleSave}
>
  저장
</LoadingButton>

<SmartSnackbar notifications={notifications} />
```

## 📊 개선 효과

### 사용자 경험
- **명확한 피드백**: 모든 액션에 대한 즉각적인 반응
- **직관적 인터페이스**: 시각적 계층구조로 사용 흐름 개선
- **모바일 최적화**: 터치 기반 인터랙션 완벽 지원

### 개발 효율성
- **재사용 가능한 컴포넌트**: 일관된 디자인 시스템
- **타입 안전성**: TypeScript로 props 검증
- **유지보수성**: 테마 시스템으로 전역 스타일 관리

## 🎯 핵심 포인트

1. **사용자 중심 설계**: 피드백과 상호작용에 중점
2. **일관성 유지**: 테마 시스템으로 디자인 통일성 확보
3. **접근성 고려**: ARIA 속성과 키보드 네비게이션 지원
4. **모바일 우선**: 반응형 디자인과 터치 최적화

Material-UI의 고급 기능들을 제대로 활용하면, 사용자에게 더 나은 경험을 제공하면서도 개발 효율성을 크게 향상시킬 수 있습니다! 🎨
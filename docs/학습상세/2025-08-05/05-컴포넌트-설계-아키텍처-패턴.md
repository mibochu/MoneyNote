# 컴포넌트 설계 아키텍처 패턴

## 🎯 학습 목표
React 컴포넌트를 체계적이고 재사용 가능하며 유지보수하기 쉽게 설계하는 아키텍처 패턴을 익힌다.

## 🤔 왜 아키텍처 패턴이 중요한가?

### 무계획적 컴포넌트 개발의 문제점
초보 개발자가 만드는 컴포넌트는 보통 이런 모습입니다:

```typescript
// 모든 것이 한 컴포넌트에 섞여있는 예시
const ExpenseManager = () => {
  // 20개의 useState
  const [amount, setAmount] = useState(0);
  const [category, setCategory] = useState('');
  const [expenses, setExpenses] = useState([]);
  const [categories, setCategories] = useState([]);
  const [loading, setLoading] = useState(false);
  // ... 16개 더
  
  // 100줄의 비즈니스 로직
  const validateForm = () => { /* ... */ };
  const saveExpense = () => { /* ... */ };
  const loadCategories = () => { /* ... */ };
  const calculateTotal = () => { /* ... */ };
  // ... 많은 함수들
  
  // 200줄의 JSX
  return (
    <div>
      {/* 폼 UI */}
      {/* 목록 UI */}
      {/* 통계 UI */}
      {/* 필터 UI */}
    </div>
  );
};
```

**문제점들:**
- 하나의 컴포넌트가 너무 많은 책임을 가짐
- 재사용이 불가능함
- 테스트하기 어려움
- 버그 수정 시 영향 범위가 넓음
- 여러 개발자가 동시에 작업하기 어려움

## 🏗️ 단일 책임 원칙 (Single Responsibility Principle)

### 컴포넌트의 책임 분리
각 컴포넌트는 하나의 명확한 책임만 가져야 합니다:

```typescript
// ❌ 나쁜 예: 모든 것을 하는 컴포넌트
const ExpenseManager = () => {
  // 폼 처리 + 목록 관리 + 통계 계산 + API 호출
};

// ✅ 좋은 예: 책임별로 분리된 컴포넌트들
const ExpenseForm = () => {
  // 오직 폼 입력과 검증만 담당
};

const ExpenseList = () => {
  // 오직 목록 표시만 담당
};

const ExpenseStats = () => {
  // 오직 통계 계산과 표시만 담당
};

const ExpenseManager = () => {
  // 오직 각 컴포넌트들의 조합과 데이터 흐름만 담당
  return (
    <>
      <ExpenseForm onSubmit={handleSubmit} />
      <ExpenseStats expenses={expenses} />
      <ExpenseList expenses={expenses} onDelete={handleDelete} />
    </>
  );
};
```

## 🎭 Container/Presentational 패턴

### Presentational 컴포넌트 (순수 UI)
데이터 표시와 사용자 인터랙션만 담당:

```typescript
interface ExpenseFormProps {
  // 데이터
  formData: ExpenseFormData;
  errors: FormErrors;
  categories: Category[];
  isLoading: boolean;
  
  // 이벤트 핸들러
  onFieldChange: (field: keyof ExpenseFormData, value: any) => void;
  onSubmit: (data: ExpenseFormData) => void;
  onCancel: () => void;
}

const ExpenseForm: React.FC<ExpenseFormProps> = ({
  formData,
  errors,
  categories,
  isLoading,
  onFieldChange,
  onSubmit,
  onCancel
}) => {
  // 순수한 UI 로직만
  const handleAmountChange = (amount: number) => {
    onFieldChange('amount', amount);
  };
  
  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    onSubmit(formData);
  };
  
  return (
    <Card>
      <form onSubmit={handleSubmit}>
        <CurrencyInput
          value={formData.amount}
          onChange={handleAmountChange}
          error={!!errors.amount}
          helperText={errors.amount}
        />
        {/* 다른 필드들... */}
        
        <Box sx={{ display: 'flex', gap: 2, mt: 3 }}>
          <Button
            type="submit"
            variant="contained"
            disabled={isLoading}
            startIcon={isLoading ? <CircularProgress size={20} /> : <SaveIcon />}
          >
            {isLoading ? '저장 중...' : '저장'}
          </Button>
          <Button onClick={onCancel}>취소</Button>
        </Box>
      </form>
    </Card>
  );
};
```

### Container 컴포넌트 (로직 처리)
비즈니스 로직과 상태 관리만 담당:

```typescript
const ExpenseFormContainer: React.FC<ContainerProps> = ({
  initialData,
  onSuccess,
  onCancel
}) => {
  // 상태 관리
  const [formData, setFormData] = useState<ExpenseFormData>(
    initialData || getDefaultFormData()
  );
  const [errors, setErrors] = useState<FormErrors>({});
  const [isLoading, setIsLoading] = useState(false);
  
  // 외부 의존성
  const { addExpense, updateExpense } = useExpenses();
  const { categories } = useCategories();
  
  // 비즈니스 로직
  const handleFieldChange = useCallback((field: keyof ExpenseFormData, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // 실시간 검증
    const error = validateField(field, value);
    setErrors(prev => ({ ...prev, [field]: error || undefined }));
  }, []);
  
  const handleSubmit = useCallback(async (data: ExpenseFormData) => {
    setIsLoading(true);
    
    try {
      // 전체 검증
      const validation = validateExpenseForm(data);
      if (!validation.isValid) {
        setErrors(validation.errors);
        return;
      }
      
      // 데이터 저장
      if (initialData?.id) {
        await updateExpense(initialData.id, data);
      } else {
        await addExpense(data);
      }
      
      onSuccess?.();
    } catch (error) {
      setErrors({ _general: '저장 중 오류가 발생했습니다.' });
    } finally {
      setIsLoading(false);
    }
  }, [initialData, addExpense, updateExpense, onSuccess]);
  
  // Presentational 컴포넌트에 props 전달
  return (
    <ExpenseForm
      formData={formData}
      errors={errors}
      categories={categories}
      isLoading={isLoading}
      onFieldChange={handleFieldChange}
      onSubmit={handleSubmit}
      onCancel={onCancel}
    />
  );
};
```

## 🧩 컴포넌트 조합 패턴 (Composition Pattern)

### Compound Components 패턴
관련된 컴포넌트들을 하나의 그룹으로 묶어 사용:

```typescript
// ExpenseCard 컴파운드 컴포넌트
const ExpenseCard = ({ children, expense, ...props }) => {
  return (
    <Card {...props}>
      <ExpenseContext.Provider value={{ expense }}>
        {children}
      </ExpenseContext.Provider>
    </Card>
  );
};

// 하위 컴포넌트들
ExpenseCard.Header = ({ children }) => {
  const { expense } = useExpenseContext();
  return (
    <CardHeader
      title={expense.description}
      subheader={formatDate(expense.date)}
    >
      {children}
    </CardHeader>
  );
};

ExpenseCard.Amount = ({ className }) => {
  const { expense } = useExpenseContext();
  return (
    <Typography variant="h6" className={className}>
      ₩{expense.amount.toLocaleString()}
    </Typography>
  );
};

ExpenseCard.Tags = () => {
  const { expense } = useExpenseContext();
  return (
    <Stack direction="row" spacing={1}>
      {expense.tags.map(tag => (
        <Chip key={tag} label={tag} size="small" />
      ))}
    </Stack>
  );
};

ExpenseCard.Actions = ({ onEdit, onDelete }) => {
  const { expense } = useExpenseContext();
  return (
    <CardActions>
      <Button onClick={() => onEdit(expense.id)}>수정</Button>
      <Button onClick={() => onDelete(expense.id)}>삭제</Button>
    </CardActions>
  );
};

// 사용 예시
const ExpenseItem = ({ expense, onEdit, onDelete }) => {
  return (
    <ExpenseCard expense={expense}>
      <ExpenseCard.Header />
      <CardContent>
        <ExpenseCard.Amount />
        <ExpenseCard.Tags />
      </CardContent>
      <ExpenseCard.Actions onEdit={onEdit} onDelete={onDelete} />
    </ExpenseCard>
  );
};
```

### Render Props 패턴
렌더링 로직을 props로 전달하여 유연성 확보:

```typescript
interface ExpenseListProps<T> {
  expenses: T[];
  loading?: boolean;
  error?: string | null;
  renderItem: (expense: T, index: number) => React.ReactNode;
  renderEmpty?: () => React.ReactNode;
  renderError?: (error: string) => React.ReactNode;
  renderLoading?: () => React.ReactNode;
}

const ExpenseList = <T extends Expense>({
  expenses,
  loading = false,
  error = null,
  renderItem,
  renderEmpty = () => <EmptyState message="지출 내역이 없습니다" />,
  renderError = (error) => <ErrorState message={error} />,
  renderLoading = () => <LoadingSpinner />
}: ExpenseListProps<T>) => {
  if (loading) return renderLoading();
  if (error) return renderError(error);
  if (expenses.length === 0) return renderEmpty();
  
  return (
    <List>
      {expenses.map((expense, index) => (
        <React.Fragment key={expense.id}>
          {renderItem(expense, index)}
          {index < expenses.length - 1 && <Divider />}
        </React.Fragment>
      ))}
    </List>
  );
};

// 사용 예시
const ExpenseListPage = () => {
  const { expenses, loading, error } = useExpenses();
  
  return (
    <ExpenseList
      expenses={expenses}
      loading={loading}
      error={error}
      renderItem={(expense) => (
        <ExpenseCard expense={expense}>
          <ExpenseCard.Header />
          <CardContent>
            <ExpenseCard.Amount />
            <ExpenseCard.Tags />
          </CardContent>
        </ExpenseCard>
      )}
      renderEmpty={() => (
        <Box textAlign="center" py={4}>
          <Typography variant="h6" color="text.secondary">
            아직 지출 내역이 없습니다
          </Typography>
          <Button variant="contained" sx={{ mt: 2 }}>
            지출 추가하기
          </Button>
        </Box>
      )}
    />
  );
};
```

## 🎨 Props 인터페이스 설계 원칙

### 1. 타입 안전성 우선
```typescript
// ❌ 약한 타입 정의
interface BadProps {
  data: any;
  onChange: (value: any) => void;
  config: object;
}

// ✅ 강한 타입 정의
interface GoodProps {
  expense: Expense;
  onExpenseChange: (field: keyof Expense, value: Expense[keyof Expense]) => void;
  validationRules: ValidationRules;
  categories: Category[];
}
```

### 2. 옵셔널 vs 필수 구분
```typescript
interface ExpenseFormProps {
  // 필수 props
  categories: Category[];
  onSubmit: (data: ExpenseFormData) => void;
  
  // 옵셔널 props (기본값 있음)
  initialData?: Partial<ExpenseFormData>;
  isLoading?: boolean;
  onCancel?: () => void;
  
  // 조건부 props
  editMode?: boolean;
  expenseId?: string; // editMode가 true일 때만 필요
}
```

### 3. 확장 가능한 설계
```typescript
// 기본 Props 인터페이스
interface BaseComponentProps {
  className?: string;
  style?: React.CSSProperties;
  'data-testid'?: string;
}

// 확장된 Props 인터페이스
interface ExpenseCardProps extends BaseComponentProps {
  expense: Expense;
  variant?: 'default' | 'compact' | 'detailed';
  actions?: Array<{
    label: string;
    icon?: React.ReactNode;
    onClick: (expense: Expense) => void;
    disabled?: boolean;
  }>;
}
```

## 🔄 상태 끌어올리기 (Lifting State Up) 패턴

### 공통 상태를 상위 컴포넌트로 이동
```typescript
// ❌ 각 컴포넌트가 독립적인 상태를 가짐
const BadExpenseManager = () => {
  return (
    <>
      <ExpenseForm /> {/* 내부에 expenses 상태 */}
      <ExpenseList /> {/* 내부에 expenses 상태 */}
    </>
  );
};

// ✅ 상위 컴포넌트에서 상태를 관리하고 하위로 전달
const GoodExpenseManager = () => {
  const { expenses, addExpense, deleteExpense } = useExpenses();
  
  return (
    <>
      <ExpenseForm 
        onSubmit={addExpense}
        categories={categories}
      />
      <ExpenseList 
        expenses={expenses}
        onDelete={deleteExpense}
      />
    </>
  );
};
```

## 🧪 테스트 친화적 설계

### 순수 함수형 컴포넌트
```typescript
// 테스트하기 쉬운 순수 컴포넌트
const ExpenseAmount: React.FC<{
  amount: number;
  currency?: string;
  precision?: number;
}> = ({
  amount,
  currency = '₩',
  precision = 0
}) => {
  const formattedAmount = formatCurrency(amount, currency, precision);
  
  return (
    <Typography 
      variant="h6" 
      color={amount >= 0 ? 'text.primary' : 'error.main'}
      data-testid="expense-amount"
    >
      {formattedAmount}
    </Typography>
  );
};

// 테스트 코드
describe('ExpenseAmount', () => {
  test('양수 금액을 올바르게 표시', () => {
    render(<ExpenseAmount amount={1000} />);
    expect(screen.getByTestId('expense-amount')).toHaveTextContent('₩1,000');
  });
  
  test('음수 금액을 에러 색상으로 표시', () => {
    render(<ExpenseAmount amount={-500} />);
    const element = screen.getByTestId('expense-amount');
    expect(element).toHaveTextContent('₩-500');
    expect(element).toHaveStyle('color: rgb(211, 47, 47)'); // error.main
  });
});
```

## 📁 폴더 구조 설계

### Feature-based 구조
```
src/
├── components/           # 재사용 가능한 UI 컴포넌트
│   ├── ui/              # 기본 UI 요소
│   │   ├── Button/
│   │   ├── Input/
│   │   └── Select/
│   ├── forms/           # 폼 관련 컴포넌트
│   │   ├── ExpenseForm/
│   │   └── CategoryForm/
│   └── common/          # 공통 컴포넌트
│       ├── Layout/
│       └── Navigation/
├── features/            # 기능별 모듈
│   ├── expenses/
│   │   ├── components/  # 지출 관련 컴포넌트
│   │   │   ├── ExpenseCard/
│   │   │   ├── ExpenseList/
│   │   │   └── ExpenseStats/
│   │   ├── hooks/       # 지출 관련 훅
│   │   │   ├── useExpenses.ts
│   │   │   └── useExpenseValidation.ts
│   │   ├── services/    # 지출 관련 서비스
│   │   │   └── expenseService.ts
│   │   └── types/       # 지출 관련 타입
│   │       └── expense.types.ts
│   └── categories/
│       └── ... (같은 구조)
└── shared/              # 공유 코드
    ├── utils/
    ├── types/
    └── constants/
```

### 컴포넌트 내부 구조
```
ExpenseForm/
├── ExpenseForm.tsx      # 메인 컴포넌트
├── ExpenseForm.test.tsx # 테스트 파일
├── ExpenseForm.stories.tsx # Storybook 스토리
├── hooks/               # 컴포넌트 전용 hooks
│   ├── useExpenseForm.ts
│   └── useExpenseValidation.ts
├── components/          # 하위 컴포넌트들
│   ├── AmountInput.tsx
│   ├── CategorySelect.tsx
│   └── TagInput.tsx
└── index.ts            # 배럴 export
```

## 🎯 실제 적용 사례

### Before (단일 거대 컴포넌트)
```typescript
const ExpenseManager = () => {
  // 300줄의 코드
  // 모든 로직이 한 곳에 섞여있음
  return (
    <div>
      {/* 500줄의 JSX */}
    </div>
  );
};
```

### After (아키텍처 패턴 적용)
```typescript
// 각각 30-50줄의 작은 컴포넌트들
const ExpenseForm = (props) => { /* 폼 UI만 */ };
const ExpenseFormContainer = (props) => { /* 폼 로직만 */ };
const ExpenseList = (props) => { /* 목록 UI만 */ };
const ExpenseStats = (props) => { /* 통계 UI만 */ };

// 조합 컴포넌트 (50줄)
const ExpenseManager = () => {
  return (
    <Box>
      <ExpenseFormContainer onSuccess={handleSuccess} />
      <ExpenseStats expenses={expenses} />
      <ExpenseList expenses={expenses} onDelete={handleDelete} />
    </Box>
  );
};
```

## 📊 아키텍처 패턴의 장점

### 개발 효율성
1. **병렬 개발**: 여러 개발자가 동시에 다른 컴포넌트 작업 가능
2. **재사용성**: 잘 설계된 컴포넌트는 다른 곳에서도 활용 가능
3. **테스트 용이성**: 작은 단위로 쪼개져 테스트하기 쉬움

### 유지보수성
1. **버그 격리**: 문제 발생 시 영향 범위가 제한적
2. **기능 확장**: 새로운 요구사항에 유연하게 대응
3. **코드 이해**: 각 컴포넌트의 역할이 명확함

### 코드 품질
1. **단일 책임**: 각 컴포넌트가 하나의 일만 잘함
2. **타입 안전성**: 명확한 인터페이스로 런타임 에러 방지
3. **일관성**: 패턴을 따라 예측 가능한 코드 구조

## 🎯 핵심 설계 원칙

1. **단일 책임 원칙**: 각 컴포넌트는 하나의 역할만
2. **관심사 분리**: UI와 비즈니스 로직을 분리
3. **재사용성 고려**: 다른 곳에서도 쓸 수 있게 설계
4. **타입 안전성**: TypeScript로 인터페이스 명확히 정의
5. **테스트 용이성**: 순수 함수형 컴포넌트로 설계

이런 아키텍처 패턴들을 적용하면, 확장 가능하고 유지보수하기 쉬운 컴포넌트 시스템을 구축할 수 있습니다! 🏗️
# ì‚¬ìš©ì ê²½í—˜ ìµœì í™” ê¸°ë²•

## ğŸ¯ í•™ìŠµ ëª©í‘œ
React ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‚¬ìš©ì ê²½í—˜(UX)ì„ ê·¹ëŒ€í™”í•˜ëŠ” êµ¬ì²´ì ì¸ ê¸°ë²•ë“¤ì„ ìµíˆê³  ì‹¤ì œ í”„ë¡œì íŠ¸ì— ì ìš©í•œë‹¤.

## ğŸ’¡ UXê°€ ì¤‘ìš”í•œ ì´ìœ 

### ì¢‹ì€ UX vs ë‚˜ìœ UX
**ë‚˜ìœ UXì˜ ì˜ˆì‹œ:**
```typescript
// ì‚¬ìš©ìê°€ ë­˜ í•´ì•¼ í• ì§€ ëª¨ë¥´ëŠ” í¼
const BadForm = () => {
  const [amount, setAmount] = useState('');
  const [error, setError] = useState('');
  
  const handleSubmit = () => {
    if (!amount) {
      setError('ì…ë ¥í•˜ì„¸ìš”'); // ë­˜ ì…ë ¥í•˜ë¼ëŠ” ê±´ì§€ ë¶ˆë¶„ëª…
      return;
    }
    // ì €ì¥ ì¤‘ì¸ì§€ ì™„ë£ŒëëŠ”ì§€ ì•Œ ìˆ˜ ì—†ìŒ
    saveData(amount);
  };
  
  return (
    <div>
      <input value={amount} onChange={e => setAmount(e.target.value)} />
      {error && <span>{error}</span>}
      <button onClick={handleSubmit}>ì €ì¥</button>
    </div>
  );
};
```

**ì¢‹ì€ UXì˜ ì˜ˆì‹œ:**
```typescript
// ì‚¬ìš©ìê°€ ëª…í™•íˆ ì•Œ ìˆ˜ ìˆëŠ” í¼
const GoodForm = () => {
  const [amount, setAmount] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitted, setSubmitted] = useState(false);
  const [error, setError] = useState('');
  
  const handleSubmit = async () => {
    setIsSubmitting(true);
    try {
      await saveData(amount);
      setSubmitted(true);
      // ì„±ê³µ í”¼ë“œë°±
      showSuccessMessage('ì§€ì¶œì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
    } catch (err) {
      setError('ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <Box>
      <TextField
        label="ì§€ì¶œ ê¸ˆì•¡"
        placeholder="ì˜ˆ: 15,000"
        value={amount}
        onChange={e => setAmount(e.target.value)}
        error={!!error}
        helperText={error || "ìˆ«ìë§Œ ì…ë ¥í•˜ì„¸ìš”"}
        InputProps={{
          startAdornment: <InputAdornment position="start">â‚©</InputAdornment>
        }}
      />
      
      <Button
        onClick={handleSubmit}
        disabled={!amount || isSubmitting}
        startIcon={isSubmitting ? <CircularProgress size={20} /> : <SaveIcon />}
      >
        {isSubmitting ? 'ì €ì¥ ì¤‘...' : 'ì €ì¥'}
      </Button>
      
      {submitted && (
        <Alert severity="success">
          ì§€ì¶œì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!
        </Alert>
      )}
    </Box>
  );
};
```

## ğŸš€ ì‹¤ì‹œê°„ í”¼ë“œë°± ì‹œìŠ¤í…œ

### 1. ì…ë ¥ ì¤‘ ì¦‰ì‹œ ê²€ì¦
ì‚¬ìš©ìê°€ ì…ë ¥í•˜ëŠ” ë™ì•ˆ ì‹¤ì‹œê°„ìœ¼ë¡œ í”¼ë“œë°±ì„ ì œê³µí•©ë‹ˆë‹¤:

```typescript
const SmartAmountInput: React.FC<SmartAmountInputProps> = ({
  value,
  onChange,
  onValidationChange
}) => {
  const [displayValue, setDisplayValue] = useState('');
  const [status, setStatus] = useState<'idle' | 'valid' | 'invalid'>('idle');
  const [message, setMessage] = useState('');
  
  const validateAmount = useCallback((amount: string) => {
    const numericValue = parseFloat(amount.replace(/,/g, ''));
    
    if (!amount.trim()) {
      setStatus('idle');
      setMessage('ê¸ˆì•¡ì„ ì…ë ¥í•˜ì„¸ìš”');
      return false;
    }
    
    if (isNaN(numericValue)) {
      setStatus('invalid');
      setMessage('ì˜¬ë°”ë¥¸ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”');
      return false;
    }
    
    if (numericValue <= 0) {
      setStatus('invalid');
      setMessage('0ë³´ë‹¤ í° ê¸ˆì•¡ì„ ì…ë ¥í•˜ì„¸ìš”');
      return false;
    }
    
    if (numericValue > 10000000) {
      setStatus('invalid');
      setMessage('ì²œë§Œì› ì´í•˜ì˜ ê¸ˆì•¡ì„ ì…ë ¥í•˜ì„¸ìš”');
      return false;
    }
    
    setStatus('valid');
    setMessage('ì˜¬ë°”ë¥¸ ê¸ˆì•¡ì…ë‹ˆë‹¤');
    return true;
  }, []);
  
  // ë””ë°”ìš´ìŠ¤ë¥¼ í™œìš©í•œ ì‹¤ì‹œê°„ ê²€ì¦
  const debouncedValidation = useDebounce((value: string) => {
    const isValid = validateAmount(value);
    onValidationChange?.(isValid);
  }, 300);
  
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const inputValue = event.target.value;
    const formattedValue = formatCurrency(inputValue);
    
    setDisplayValue(formattedValue);
    onChange?.(formattedValue);
    debouncedValidation(inputValue);
  };
  
  // ìƒ‰ìƒ í…Œë§ˆì— ë”°ë¥¸ ìŠ¤íƒ€ì¼ë§
  const getStatusColor = () => {
    switch (status) {
      case 'valid': return 'success.main';
      case 'invalid': return 'error.main';
      default: return 'text.secondary';
    }
  };
  
  const getStatusIcon = () => {
    switch (status) {
      case 'valid': return <CheckCircleIcon fontSize="small" />;
      case 'invalid': return <ErrorIcon fontSize="small" />;
      default: return <InfoIcon fontSize="small" />;
    }
  };
  
  return (
    <TextField
      label="ì§€ì¶œ ê¸ˆì•¡"
      value={displayValue}
      onChange={handleChange}
      placeholder="ì˜ˆ: 15,000"
      InputProps={{
        startAdornment: (
          <InputAdornment position="start">â‚©</InputAdornment>
        ),
        endAdornment: (
          <InputAdornment position="end">
            <Tooltip title={message}>
              <Box sx={{ color: getStatusColor() }}>
                {getStatusIcon()}
              </Box>
            </Tooltip>
          </InputAdornment>
        )
      }}
      helperText={
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
          <Box sx={{ color: getStatusColor() }}>
            {getStatusIcon()}
          </Box>
          <Typography variant="caption" sx={{ color: getStatusColor() }}>
            {message}
          </Typography>
        </Box>
      }
      sx={{
        '& .MuiOutlinedInput-root': {
          '&.Mui-focused fieldset': {
            borderColor: getStatusColor()
          }
        }
      }}
    />
  );
};
```

### 2. í”„ë¡œê·¸ë ˆì‹œë¸Œ ë””ìŠ¤í´ë¡œì € (Progressive Disclosure)
ë³µì¡í•œ ì •ë³´ë¥¼ ë‹¨ê³„ì ìœ¼ë¡œ ê³µê°œí•˜ì—¬ ì¸ì§€ ë¶€ë‹´ì„ ì¤„ì…ë‹ˆë‹¤:

```typescript
const ExpenseFormStepper: React.FC = () => {
  const [activeStep, setActiveStep] = useState(0);
  const [formData, setFormData] = useState<ExpenseFormData>(initialData);
  const [completed, setCompleted] = useState<Set<number>>(new Set());
  
  const steps = [
    {
      label: 'ê¸°ë³¸ ì •ë³´',
      description: 'ê¸ˆì•¡ê³¼ ë‚ ì§œë¥¼ ì…ë ¥í•˜ì„¸ìš”',
      component: BasicInfoStep,
      required: true
    },
    {
      label: 'ë¶„ë¥˜',
      description: 'ì¹´í…Œê³ ë¦¬ì™€ ê²°ì œìˆ˜ë‹¨ì„ ì„ íƒí•˜ì„¸ìš”',
      component: CategoryStep,
      required: true
    },
    {
      label: 'ìƒì„¸ ì •ë³´',
      description: 'ì„¤ëª…ê³¼ íƒœê·¸ë¥¼ ì¶”ê°€í•˜ì„¸ìš”',
      component: DetailStep,
      required: false
    }
  ];
  
  const handleNext = () => {
    setCompleted(prev => new Set([...prev, activeStep]));
    setActiveStep(prev => prev + 1);
  };
  
  const handleBack = () => {
    setActiveStep(prev => prev - 1);
  };
  
  const isStepValid = (step: number) => {
    switch (step) {
      case 0:
        return formData.amount > 0 && formData.date;
      case 1:
        return formData.category && formData.paymentMethod;
      case 2:
        return true; // ì„ íƒì  ë‹¨ê³„
      default:
        return false;
    }
  };
  
  return (
    <Box>
      {/* ìŠ¤í… ì¸ë””ì¼€ì´í„° */}
      <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
        {steps.map((step, index) => (
          <Step key={step.label} completed={completed.has(index)}>
            <StepLabel
              optional={
                !step.required && (
                  <Typography variant="caption">ì„ íƒì‚¬í•­</Typography>
                )
              }
              StepIconComponent={(props) => (
                <CustomStepIcon
                  {...props}
                  completed={completed.has(index)}
                  valid={isStepValid(index)}
                />
              )}
            >
              {step.label}
            </StepLabel>
          </Step>
        ))}
      </Stepper>
      
      {/* í˜„ì¬ ë‹¨ê³„ ë‚´ìš© */}
      <Box sx={{ minHeight: 400 }}>
        <Typography variant="h6" gutterBottom>
          {steps[activeStep].label}
        </Typography>
        <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
          {steps[activeStep].description}
        </Typography>
        
        <steps[activeStep].component
          formData={formData}
          onChange={setFormData}
        />
      </Box>
      
      {/* ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼ */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4 }}>
        <Button
          onClick={handleBack}
          disabled={activeStep === 0}
          startIcon={<ArrowBackIcon />}
        >
          ì´ì „
        </Button>
        
        <Box sx={{ display: 'flex', gap: 2 }}>
          {activeStep < steps.length - 1 && (
            <Button
              variant="outlined"
              onClick={() => setActiveStep(steps.length - 1)}
            >
              ê±´ë„ˆë›°ê¸°
            </Button>
          )}
          
          <Button
            variant="contained"
            onClick={activeStep === steps.length - 1 ? handleSubmit : handleNext}
            disabled={steps[activeStep].required && !isStepValid(activeStep)}
            endIcon={activeStep === steps.length - 1 ? <SaveIcon /> : <ArrowForwardIcon />}
          >
            {activeStep === steps.length - 1 ? 'ì €ì¥' : 'ë‹¤ìŒ'}
          </Button>
        </Box>
      </Box>
    </Box>
  );
};
```

## âš¡ ì„±ëŠ¥ ìµœì í™”ë¥¼ í†µí•œ UX í–¥ìƒ

### 1. ê°€ìƒí™”ë¥¼ í†µí•œ ëŒ€ìš©ëŸ‰ ë¦¬ìŠ¤íŠ¸ ìµœì í™”
```typescript
const VirtualizedExpenseList: React.FC<VirtualizedExpenseListProps> = ({
  expenses,
  onExpenseClick
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [containerHeight, setContainerHeight] = useState(400);
  
  // ì»¨í…Œì´ë„ˆ í¬ê¸° ìë™ ì¡°ì •
  useEffect(() => {
    const updateHeight = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const availableHeight = viewportHeight - rect.top - 100; // ì—¬ë°± ê³ ë ¤
        setContainerHeight(Math.max(300, availableHeight));
      }
    };
    
    updateHeight();
    window.addEventListener('resize', updateHeight);
    return () => window.removeEventListener('resize', updateHeight);
  }, []);
  
  const itemHeight = 80; // ê° ì•„ì´í…œì˜ ê³ ì • ë†’ì´
  
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {
    const expense = expenses[index];
    
    return (
      <div style={style}>
        <ExpenseItem
          expense={expense}
          onClick={() => onExpenseClick(expense)}
        />
      </div>
    );
  };
  
  return (
    <Box ref={containerRef} sx={{ height: containerHeight }}>
      <FixedSizeList
        height={containerHeight}
        itemCount={expenses.length}
        itemSize={itemHeight}
        overscanCount={5} // ì„±ëŠ¥ì„ ìœ„í•œ ì˜¤ë²„ìŠ¤ìº”
      >
        {Row}
      </FixedSizeList>
    </Box>
  );
};
```

### 2. ì§€ì—° ë¡œë”©ê³¼ ìŠ¤ì¼ˆë ˆí†¤ UI
```typescript
const LazyExpenseChart: React.FC<LazyExpenseChartProps> = ({ expenses }) => {
  const [isVisible, setIsVisible] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [ChartComponent, setChartComponent] = useState<React.ComponentType | null>(null);
  const ref = useRef<HTMLDivElement>(null);
  
  // Intersection Observerë¡œ í™”ë©´ì— ë³´ì¼ ë•Œë§Œ ë¡œë“œ
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
        }
      },
      { threshold: 0.1 }
    );
    
    if (ref.current) {
      observer.observe(ref.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  // ì»´í¬ë„ŒíŠ¸ ì§€ì—° ë¡œë”©
  useEffect(() => {
    if (isVisible && !ChartComponent) {
      setIsLoading(true);
      
      // ë™ì  importë¡œ ì°¨íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ
      import('../components/ExpenseChart').then(({ ExpenseChart }) => {
        setChartComponent(() => ExpenseChart);
        setIsLoading(false);
      });
    }
  }, [isVisible, ChartComponent]);
  
  return (
    <Box ref={ref} sx={{ minHeight: 300 }}>
      {isLoading && <ChartSkeleton />}
      {ChartComponent && <ChartComponent expenses={expenses} />}
      {!isVisible && (
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: 300 }}>
          <Typography color="text.secondary">
            ì°¨íŠ¸ë¥¼ ë³´ë ¤ë©´ ìŠ¤í¬ë¡¤í•˜ì„¸ìš”
          </Typography>
        </Box>
      )}
    </Box>
  );
};

// ìŠ¤ì¼ˆë ˆí†¤ UI ì»´í¬ë„ŒíŠ¸
const ChartSkeleton: React.FC = () => (
  <Box sx={{ p: 2 }}>
    <Skeleton variant="text" width="40%" height={32} sx={{ mb: 2 }} />
    <Skeleton variant="circular" width={200} height={200} sx={{ mx: 'auto', mb: 2 }} />
    <Stack direction="row" spacing={2} justifyContent="center">
      {Array.from({ length: 4 }).map((_, index) => (
        <Skeleton key={index} variant="rectangular" width={80} height={20} />
      ))}
    </Stack>
  </Box>
);
```

## ğŸ¨ ì ‘ê·¼ì„±(Accessibility) í–¥ìƒ

### 1. í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ì§€ì›
```typescript
const AccessibleExpenseForm: React.FC = () => {
  const formRef = useRef<HTMLFormElement>(null);
  const [focusedFieldIndex, setFocusedFieldIndex] = useState(0);
  
  const fields = [
    'amount',
    'category',
    'description',
    'paymentMethod',
    'tags'
  ];
  
  const handleKeyDown = (event: React.KeyboardEvent) => {
    switch (event.key) {
      case 'Tab':
        // Tab í‚¤ ë„¤ë¹„ê²Œì´ì…˜ì€ ë¸Œë¼ìš°ì € ê¸°ë³¸ ë™ì‘ ì‚¬ìš©
        break;
        
      case 'Enter':
        if (event.ctrlKey || event.metaKey) {
          // Ctrl+Enterë¡œ ë¹ ë¥¸ ì €ì¥
          event.preventDefault();
          handleSubmit();
        }
        break;
        
      case 'Escape':
        // ESCë¡œ í¼ ì·¨ì†Œ
        event.preventDefault();
        handleCancel();
        break;
        
      case 'ArrowDown':
      case 'ArrowUp':
        // í™”ì‚´í‘œ í‚¤ë¡œ í•„ë“œ ê°„ ì´ë™ (íŠ¹ì • ìƒí™©ì—ì„œ)
        if (event.altKey) {
          event.preventDefault();
          const direction = event.key === 'ArrowDown' ? 1 : -1;
          const nextIndex = Math.max(0, Math.min(fields.length - 1, 
            focusedFieldIndex + direction));
          setFocusedFieldIndex(nextIndex);
          
          // í•´ë‹¹ í•„ë“œì— í¬ì»¤ìŠ¤
          const fieldElement = formRef.current?.querySelector(
            `[name="${fields[nextIndex]}"]`
          ) as HTMLElement;
          fieldElement?.focus();
        }
        break;
    }
  };
  
  return (
    <form
      ref={formRef}
      onKeyDown={handleKeyDown}
      role="form"
      aria-label="ì§€ì¶œ ì…ë ¥ í¼"
    >
      <fieldset>
        <legend>ê¸°ë³¸ ì •ë³´</legend>
        
        <TextField
          name="amount"
          label="ê¸ˆì•¡"
          required
          aria-describedby="amount-help"
          inputProps={{
            'aria-label': 'ì§€ì¶œ ê¸ˆì•¡ì„ ì› ë‹¨ìœ„ë¡œ ì…ë ¥í•˜ì„¸ìš”',
            inputMode: 'numeric'
          }}
        />
        <Typography id="amount-help" variant="caption" component="div">
          ì˜ˆ: 15000 (ì‰¼í‘œ ì—†ì´ ìˆ«ìë§Œ ì…ë ¥)
        </Typography>
      </fieldset>
      
      <fieldset>
        <legend>ë¶„ë¥˜ ì •ë³´</legend>
        
        <FormControl required>
          <InputLabel id="category-label">ì¹´í…Œê³ ë¦¬</InputLabel>
          <Select
            labelId="category-label"
            name="category"
            aria-describedby="category-help"
          >
            {categories.map(category => (
              <MenuItem key={category.id} value={category.id}>
                {category.icon} {category.name}
              </MenuItem>
            ))}
          </Select>
          <FormHelperText id="category-help">
            ì§€ì¶œì˜ ìš©ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”
          </FormHelperText>
        </FormControl>
      </fieldset>
      
      {/* í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì•ˆë‚´ */}
      <Box sx={{ mt: 3, p: 2, bgcolor: 'grey.50', borderRadius: 1 }}>
        <Typography variant="caption" color="text.secondary">
          <KeyboardIcon fontSize="small" sx={{ mr: 1, verticalAlign: 'middle' }} />
          ë‹¨ì¶•í‚¤: Ctrl+Enter (ì €ì¥), ESC (ì·¨ì†Œ), Alt+í™”ì‚´í‘œ (í•„ë“œ ì´ë™)
        </Typography>
      </Box>
    </form>
  );
};
```

### 2. ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›
```typescript
const AccessibleExpenseList: React.FC<AccessibleExpenseListProps> = ({
  expenses,
  onExpenseSelect
}) => {
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const [announcementText, setAnnouncementText] = useState('');
  
  // ìŠ¤í¬ë¦° ë¦¬ë”ë¥¼ ìœ„í•œ ë™ì  ê³µì§€
  const announceChange = (text: string) => {
    setAnnouncementText(text);
    // ê³µì§€ í›„ í…ìŠ¤íŠ¸ í´ë¦¬ì–´ (ì¤‘ë³µ ì½ê¸° ë°©ì§€)
    setTimeout(() => setAnnouncementText(''), 100);
  };
  
  const handleKeyDown = (event: React.KeyboardEvent, index: number) => {
    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        const nextIndex = Math.min(expenses.length - 1, index + 1);
        setSelectedIndex(nextIndex);
        announceChange(`${nextIndex + 1}ë²ˆì§¸ ì§€ì¶œ: ${expenses[nextIndex].description}`);
        break;
        
      case 'ArrowUp':
        event.preventDefault();
        const prevIndex = Math.max(0, index - 1);
        setSelectedIndex(prevIndex);
        announceChange(`${prevIndex + 1}ë²ˆì§¸ ì§€ì¶œ: ${expenses[prevIndex].description}`);
        break;
        
      case 'Enter':
      case ' ':
        event.preventDefault();
        onExpenseSelect(expenses[index]);
        announceChange(`${expenses[index].description} í•­ëª©ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤`);
        break;
    }
  };
  
  return (
    <>
      {/* ìŠ¤í¬ë¦° ë¦¬ë”ë¥¼ ìœ„í•œ ë¼ì´ë¸Œ ë¦¬ì „ */}
      <div
        role="status"
        aria-live="polite"
        aria-atomic="true"
        className="sr-only"
      >
        {announcementText}
      </div>
      
      <List
        role="listbox"
        aria-label={`ì§€ì¶œ ëª©ë¡, ì´ ${expenses.length}ê°œ í•­ëª©`}
        tabIndex={0}
      >
        {expenses.map((expense, index) => (
          <ListItem
            key={expense.id}
            role="option"
            aria-selected={selectedIndex === index}
            tabIndex={selectedIndex === index ? 0 : -1}
            onKeyDown={(e) => handleKeyDown(e, index)}
            onClick={() => onExpenseSelect(expense)}
            sx={{
              bgcolor: selectedIndex === index ? 'action.selected' : 'transparent'
            }}
          >
            <ListItemText
              primary={
                <Box component="span" aria-label={`ì§€ì¶œ ë‚´ìš©: ${expense.description}`}>
                  {expense.description}
                </Box>
              }
              secondary={
                <Box component="span">
                  <span aria-label={`ê¸ˆì•¡: ${expense.amount.toLocaleString()}ì›`}>
                    â‚©{expense.amount.toLocaleString()}
                  </span>
                  {' â€¢ '}
                  <span aria-label={`ë‚ ì§œ: ${formatDate(expense.date)}`}>
                    {formatDate(expense.date)}
                  </span>
                  {' â€¢ '}
                  <span aria-label={`ì¹´í…Œê³ ë¦¬: ${expense.category}`}>
                    {expense.category}
                  </span>
                </Box>
              }
            />
          </ListItem>
        ))}
      </List>
    </>
  );
};
```

## ğŸ­ ë§ˆì´í¬ë¡œ ì¸í„°ë™ì…˜ ë””ìì¸

### 1. ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜
```typescript
const AnimatedExpenseCard: React.FC<AnimatedExpenseCardProps> = ({
  expense,
  isNew = false
}) => {
  const [isHovered, setIsHovered] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  
  return (
    <Box
      component={motion.div}
      initial={isNew ? { opacity: 0, y: 20, scale: 0.95 } : false}
      animate={{ 
        opacity: isDeleting ? 0 : 1, 
        y: isDeleting ? -20 : 0,
        scale: isHovered ? 1.02 : 1
      }}
      exit={{ opacity: 0, y: -20, scale: 0.95 }}
      transition={{ 
        duration: 0.2, 
        ease: [0.4, 0.0, 0.2, 1] // Material Design ì´ì§•
      }}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onHoverStart={() => setIsHovered(true)}
      onHoverEnd={() => setIsHovered(false)}
    >
      <Card
        sx={{
          cursor: 'pointer',
          transition: 'box-shadow 0.2s ease-in-out',
          boxShadow: isHovered ? 4 : 1,
          '&:hover': {
            boxShadow: 6
          }
        }}
      >
        <CardContent>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Typography variant="h6">
              {expense.description}
            </Typography>
            
            <Box component={motion.div} animate={{ scale: isHovered ? 1.1 : 1 }}>
              <Chip
                label={`â‚©${expense.amount.toLocaleString()}`}
                color="primary"
                variant={isHovered ? "filled" : "outlined"}
              />
            </Box>
          </Box>
          
          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
            {formatDate(expense.date)} â€¢ {expense.category}
          </Typography>
        </CardContent>
        
        {/* í˜¸ë²„ ì‹œ ë‚˜íƒ€ë‚˜ëŠ” ì•¡ì…˜ ë²„íŠ¼ë“¤ */}
        <AnimatePresence>
          {isHovered && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.15 }}
            >
              <CardActions>
                <Button size="small" startIcon={<EditIcon />}>
                  ìˆ˜ì •
                </Button>
                <Button 
                  size="small" 
                  color="error" 
                  startIcon={<DeleteIcon />}
                  onClick={() => setIsDeleting(true)}
                >
                  ì‚­ì œ
                </Button>
              </CardActions>
            </motion.div>
          )}
        </AnimatePresence>
      </Card>
    </Box>
  );
};
```

### 2. ìƒíƒœ ë³€í™” ì‹œê°í™”
```typescript
const StatusIndicator: React.FC<StatusIndicatorProps> = ({
  status,
  message
}) => {
  const getStatusConfig = (status: Status) => {
    switch (status) {
      case 'loading':
        return {
          icon: <CircularProgress size={16} />,
          color: 'info.main',
          bgcolor: 'info.light',
          animation: 'pulse 2s infinite'
        };
      case 'success':
        return {
          icon: <CheckCircleIcon fontSize="small" />,
          color: 'success.main',
          bgcolor: 'success.light',
          animation: 'bounce 0.6s ease-out'
        };
      case 'error':
        return {
          icon: < ErrorIcon fontSize="small" />,
          color: 'error.main',
          bgcolor: 'error.light',
          animation: 'shake 0.5s ease-in-out'
        };
      default:
        return {
          icon: <InfoIcon fontSize="small" />,
          color: 'text.secondary',
          bgcolor: 'grey.100',
          animation: 'none'
        };
    }
  };
  
  const config = getStatusConfig(status);
  
  return (
    <Box
      component={motion.div}
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.8 }}
      sx={{
        display: 'flex',
        alignItems: 'center',
        gap: 1,
        p: 1,
        borderRadius: 1,
        bgcolor: config.bgcolor,
        color: config.color,
        animation: config.animation,
        '@keyframes pulse': {
          '0%, 100%': { opacity: 1 },
          '50%': { opacity: 0.5 }
        },
        '@keyframes bounce': {
          '0%, 20%, 53%, 80%, 100%': { transform: 'translateY(0)' },
          '40%, 43%': { transform: 'translateY(-8px)' },
          '70%': { transform: 'translateY(-4px)' },
          '90%': { transform: 'translateY(-2px)' }
        },
        '@keyframes shake': {
          '0%, 100%': { transform: 'translateX(0)' },
          '10%, 30%, 50%, 70%, 90%': { transform: 'translateX(-4px)' },
          '20%, 40%, 60%, 80%': { transform: 'translateX(4px)' }
        }
      }}
    >
      {config.icon}
      <Typography variant="body2" component="span">
        {message}
      </Typography>
    </Box>
  );
};
```

## ğŸ“± ëª¨ë°”ì¼ UX ìµœì í™”

### 1. í„°ì¹˜ ìµœì í™”
```typescript
const TouchOptimizedButton: React.FC<TouchOptimizedButtonProps> = ({
  children,
  onClick,
  ...props
}) => {
  const [isPressed, setIsPressed] = useState(false);
  
  return (
    <Button
      {...props}
      onTouchStart={() => setIsPressed(true)}
      onTouchEnd={() => setIsPressed(false)}
      onMouseDown={() => setIsPressed(true)}
      onMouseUp={() => setIsPressed(false)}
      onClick={onClick}
      sx={{
        minHeight: 48, // ìµœì†Œ í„°ì¹˜ íƒ€ê²Ÿ í¬ê¸°
        minWidth: 48,
        transform: isPressed ? 'scale(0.95)' : 'scale(1)',
        transition: 'transform 0.1s ease-out',
        ...props.sx
      }}
    >
      {children}
    </Button>
  );
};
```

### 2. ìŠ¤ì™€ì´í”„ ì œìŠ¤ì²˜
```typescript
const SwipeableExpenseItem: React.FC<SwipeableExpenseItemProps> = ({
  expense,
  onEdit,
  onDelete
}) => {
  const { handlers } = useSwipeable({
    onSwipedLeft: () => onDelete(expense.id),
    onSwipedRight: () => onEdit(expense.id),
    threshold: 100,
    preventScrollOnSwipe: true
  });
  
  return (
    <Box
      {...handlers}
      sx={{
        position: 'relative',
        overflow: 'hidden'
      }}
    >
      {/* ìŠ¤ì™€ì´í”„ íŒíŠ¸ */}
      <Box
        sx={{
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          px: 2,
          bgcolor: 'action.hover',
          zIndex: 0
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', color: 'primary.main' }}>
          <EditIcon />
          <Typography variant="caption" sx={{ ml: 1 }}>
            ìˆ˜ì •
          </Typography>
        </Box>
        <Box sx={{ display: 'flex', alignItems: 'center', color: 'error.main' }}>
          <Typography variant="caption" sx={{ mr: 1 }}>
            ì‚­ì œ
          </Typography>
          <DeleteIcon />
        </Box>
      </Box>
      
      {/* ì‹¤ì œ ì»¨í…ì¸  */}
      <ExpenseItem expense={expense} />
    </Box>
  );
};
```

## ğŸ¯ ì‹¤ì œ ì ìš© íš¨ê³¼

### Before (ê¸°ë³¸ì ì¸ UX)
- ì‚¬ìš©ìê°€ ë­˜ í•´ì•¼ í• ì§€ ëª¨ë¦„
- ì—ëŸ¬ ë°œìƒ ì‹œ ì›ì¸ì„ ì•Œ ìˆ˜ ì—†ìŒ
- ì‘ì—… ì§„í–‰ ìƒí™©ì„ ì•Œ ìˆ˜ ì—†ìŒ
- ëª¨ë°”ì¼ì—ì„œ ì‚¬ìš©í•˜ê¸° ì–´ë ¤ì›€

### After (ìµœì í™”ëœ UX)
- ê° ë‹¨ê³„ë§ˆë‹¤ ëª…í™•í•œ ê°€ì´ë“œ ì œê³µ
- ì‹¤ì‹œê°„ í”¼ë“œë°±ìœ¼ë¡œ ì¦‰ì‹œ ë¬¸ì œ í•´ê²°
- ì§„í–‰ ìƒí™©ê³¼ ê²°ê³¼ë¥¼ ëª…í™•íˆ í‘œì‹œ
- ëª¨ë“  ë””ë°”ì´ìŠ¤ì—ì„œ ì¼ê´€ëœ ê²½í—˜

## ğŸ“Š UX ê°œì„  íš¨ê³¼

### ì‚¬ìš©ì ë§Œì¡±ë„
1. **í•™ìŠµ ê³¡ì„  ë‹¨ì¶•**: ì§ê´€ì ì¸ ì¸í„°í˜ì´ìŠ¤ë¡œ ì‚¬ìš©ë²•ì„ ë¹¨ë¦¬ ìµí˜
2. **ì—ëŸ¬ ê°ì†Œ**: ì‹¤ì‹œê°„ ê²€ì¦ìœ¼ë¡œ ì˜ëª»ëœ ì…ë ¥ ë°©ì§€
3. **íš¨ìœ¨ì„± ì¦ëŒ€**: í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ì™€ ë¹ ë¥¸ ì•¡ì…˜ìœ¼ë¡œ ì‘ì—… ì†ë„ í–¥ìƒ

### ì ‘ê·¼ì„± í–¥ìƒ
1. **ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›**: ì‹œê° ì¥ì• ì¸ë„ ì‚¬ìš© ê°€ëŠ¥
2. **í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜**: ë§ˆìš°ìŠ¤ ì—†ì´ë„ ëª¨ë“  ê¸°ëŠ¥ ì´ìš© ê°€ëŠ¥
3. **ê³ ëŒ€ë¹„ ëª¨ë“œ**: ë‹¤ì–‘í•œ ì‹œê°ì  ìš”êµ¬ì‚¬í•­ ì§€ì›

### ì„±ëŠ¥ í–¥ìƒ
1. **ì§€ì—° ë¡œë”©**: í•„ìš”í•œ ë¦¬ì†ŒìŠ¤ë§Œ ë¡œë“œí•˜ì—¬ ì´ˆê¸° ë¡œë”© ì†ë„ ê°œì„ 
2. **ê°€ìƒí™”**: ëŒ€ìš©ëŸ‰ ë°ì´í„°ë„ ë¶€ë“œëŸ½ê²Œ ì²˜ë¦¬
3. **ë””ë°”ìš´ì‹±**: ë¶ˆí•„ìš”í•œ ì—°ì‚° ì¤„ì—¬ ë°°í„°ë¦¬ ìˆ˜ëª… ì—°ì¥

## ğŸ¯ í•µì‹¬ UX ì›ì¹™

1. **ì¦‰ì‹œì„±**: ì‚¬ìš©ì ì•¡ì…˜ì— ì¦‰ê°ì ì¸ í”¼ë“œë°± ì œê³µ
2. **ëª…í™•ì„±**: ë¬´ì—‡ì„ í•´ì•¼ í•˜ëŠ”ì§€ ëª…í™•í•˜ê²Œ ì•ˆë‚´
3. **ì¼ê´€ì„±**: ëª¨ë“  í™”ë©´ì—ì„œ ë™ì¼í•œ íŒ¨í„´ ì‚¬ìš©
4. **ì ‘ê·¼ì„±**: ëª¨ë“  ì‚¬ìš©ìê°€ ë™ë“±í•˜ê²Œ ì´ìš© ê°€ëŠ¥
5. **íš¨ìœ¨ì„±**: ìµœì†Œí•œì˜ ì•¡ì…˜ìœ¼ë¡œ ëª©í‘œ ë‹¬ì„±

ì´ëŸ° UX ìµœì í™” ê¸°ë²•ë“¤ì„ ì ìš©í•˜ë©´, ì‚¬ìš©ìê°€ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë” ì‰½ê³  ì¦ê²ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€
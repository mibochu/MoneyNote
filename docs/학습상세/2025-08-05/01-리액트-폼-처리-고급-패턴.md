# 리액트 폼 처리 고급 패턴

## 🎯 학습 목표
복잡한 폼 요구사항을 체계적으로 처리하는 React 패턴들을 이해하고 실제 프로젝트에 적용한다.

## 📖 배경: 왜 고급 패턴이 필요한가?

### 단순한 폼의 한계
초보자가 만드는 폼은 보통 이런 모습입니다:

```typescript
const SimpleForm = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  
  const handleSubmit = () => {
    // 검증 로직이 여기 섞여있음
    if (!name) alert('이름을 입력하세요');
    if (!email) alert('이메일을 입력하세요');
    // 저장 로직도 여기 섞여있음
    localStorage.setItem('user', JSON.stringify({name, email}));
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input value={name} onChange={e => setName(e.target.value)} />
      <input value={email} onChange={e => setEmail(e.target.value)} />
      <button type="submit">저장</button>
    </form>
  );
};
```

**문제점들:**
- 검증 로직과 UI 로직이 섞여있음
- 에러 상태 관리가 부실함
- 재사용이 어려움
- 테스트하기 복잡함

## 🏗️ 해결책: Container/Presentational 패턴

### 1단계: 데이터 구조 설계
먼저 다룰 데이터의 구조를 명확히 정의합니다:

```typescript
// 실제 저장될 데이터
interface ExpenseFormData {
  amount: number;
  category: string;
  subcategory: string;
  description: string;
  paymentMethod: PaymentMethod;
  tags: string[];
  isFixed: boolean;
  date: Date;
}

// 폼의 상태 (에러 등 추가 정보 포함)
interface FormState {
  data: ExpenseFormData;
  errors: Partial<Record<keyof ExpenseFormData, string>>;
  isSubmitting: boolean;
}
```

### 2단계: Presentational 컴포넌트 (순수 UI)
UI만 담당하는 컴포넌트를 만듭니다:

```typescript
interface ExpenseFormProps {
  // 데이터
  formData: ExpenseFormData;
  errors: Partial<Record<keyof ExpenseFormData, string>>;
  isLoading: boolean;
  
  // 이벤트 핸들러들
  onAmountChange: (amount: number) => void;
  onCategoryChange: (categoryId: string) => void;
  onDescriptionChange: (description: string) => void;
  onSubmit: (data: ExpenseFormData) => void;
  onCancel?: () => void;
  
  // 기타 설정
  categories: CategoryData[];
}

const ExpenseForm: React.FC<ExpenseFormProps> = ({
  formData,
  errors,
  isLoading,
  onAmountChange,
  onCategoryChange,
  onDescriptionChange,
  onSubmit,
  onCancel,
  categories
}) => {
  // 여기에는 순수한 UI 로직만!
  return (
    <Card>
      <CardContent>
        <CurrencyInput
          value={formData.amount}
          onAmountChange={onAmountChange}
          error={!!errors.amount}
          helperText={errors.amount}
        />
        {/* 다른 필드들... */}
      </CardContent>
    </Card>
  );
};
```

### 3단계: Container 컴포넌트 (로직 처리)
비즈니스 로직을 담당하는 컴포넌트를 만듭니다:

```typescript
const ExpenseFormContainer: React.FC<ContainerProps> = ({
  initialData,
  onSuccess,
  onCancel
}) => {
  // 상태 관리
  const [formData, setFormData] = useState<ExpenseFormData>(initialData || defaultData);
  const [errors, setErrors] = useState<FormErrors>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // 비즈니스 로직
  const { addExpense, updateExpense } = useExpenses();
  const { categories } = useCategories();
  
  // 이벤트 핸들러들
  const handleAmountChange = (amount: number) => {
    setFormData(prev => ({ ...prev, amount }));
    
    // 실시간 검증
    const error = validateField('amount', amount);
    setErrors(prev => ({ ...prev, amount: error || undefined }));
  };
  
  const handleSubmit = async (data: ExpenseFormData) => {
    setIsSubmitting(true);
    try {
      await addExpense(data);
      onSuccess?.();
    } catch (error) {
      // 에러 처리
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <ExpenseForm
      formData={formData}
      errors={errors}
      isLoading={isSubmitting}
      onAmountChange={handleAmountChange}
      onSubmit={handleSubmit}
      onCancel={onCancel}
      categories={categories}
    />
  );
};
```

## 🔍 실시간 검증 패턴

### 검증 로직의 외부화
검증 로직을 별도 파일로 분리합니다:

```typescript
// validators/expenseValidators.ts
export const validateAmount = (amount: number): string | null => {
  if (amount <= 0) return '금액은 0보다 큰 값이어야 합니다.';
  if (amount > 10000000) return '금액이 너무 큽니다.';
  return null;
};

export const validateExpenseForm = (data: ExpenseFormData) => {
  const errors: FormErrors = {};
  
  const amountError = validateAmount(data.amount);
  if (amountError) errors.amount = amountError;
  
  // 다른 검증들...
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};
```

### 실시간 검증의 구현
사용자가 입력하는 즉시 검증 결과를 보여줍니다:

```typescript
const handleFieldChange = (field: keyof ExpenseFormData, value: any) => {
  // 1. 데이터 업데이트
  setFormData(prev => ({ ...prev, [field]: value }));
  
  // 2. 실시간 검증
  const error = validateField(field, value);
  
  // 3. 에러 상태 업데이트
  setErrors(prev => ({ 
    ...prev, 
    [field]: error || undefined 
  }));
};
```

## 💡 복잡한 상태 관리 패턴

### useReducer를 활용한 상태 통합
복잡한 폼 상태는 useReducer로 관리하는 것이 좋습니다:

```typescript
interface FormState {
  data: ExpenseFormData;
  errors: FormErrors;
  isSubmitting: boolean;
  isDirty: boolean; // 사용자가 수정했는지 여부
}

type FormAction = 
  | { type: 'SET_FIELD'; field: keyof ExpenseFormData; value: any }
  | { type: 'SET_ERROR'; field: keyof ExpenseFormData; error: string | null }
  | { type: 'SET_SUBMITTING'; isSubmitting: boolean }
  | { type: 'RESET_FORM' };

const formReducer = (state: FormState, action: FormAction): FormState => {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        data: { ...state.data, [action.field]: action.value },
        isDirty: true
      };
    
    case 'SET_ERROR':
      return {
        ...state,
        errors: { 
          ...state.errors, 
          [action.field]: action.error || undefined 
        }
      };
    
    // 다른 액션들...
    
    default:
      return state;
  }
};
```

## 🎨 사용자 경험 개선 패턴

### 1. 점진적 공개 (Progressive Disclosure)
복잡한 폼을 단계별로 나누어 보여줍니다:

```typescript
const [currentStep, setCurrentStep] = useState(1);

const renderStep = () => {
  switch (currentStep) {
    case 1:
      return <BasicInfoStep />; // 금액, 날짜, 기본 정보
    case 2:
      return <CategorizationStep />; // 카테고리, 태그
    case 3:
      return <DetailsStep />; // 상세 설명, 추가 옵션
    default:
      return <BasicInfoStep />;
  }
};
```

### 2. 자동 저장 (Auto-save)
사용자의 입력을 주기적으로 임시 저장합니다:

```typescript
const useAutoSave = (data: ExpenseFormData, delay: number = 2000) => {
  const [lastSaved, setLastSaved] = useState<Date | null>(null);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      // 임시 저장
      localStorage.setItem('expense_draft', JSON.stringify(data));
      setLastSaved(new Date());
    }, delay);
    
    return () => clearTimeout(timer);
  }, [data, delay]);
  
  return lastSaved;
};
```

### 3. 스마트 기본값
사용자의 이전 입력을 기반으로 기본값을 제안합니다:

```typescript
const useSmartDefaults = () => {
  const { expenses } = useExpenses();
  
  const getDefaultCategory = () => {
    // 최근 3개 지출의 가장 많이 사용된 카테고리
    const recentExpenses = expenses.slice(0, 3);
    const categoryCount = recentExpenses.reduce((acc, expense) => {
      acc[expense.category] = (acc[expense.category] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    return Object.keys(categoryCount).sort((a, b) => 
      categoryCount[b] - categoryCount[a]
    )[0];
  };
  
  return {
    category: getDefaultCategory(),
    paymentMethod: 'card', // 가장 많이 사용하는 결제수단
    date: new Date()
  };
};
```

## 🧪 테스트하기 쉬운 구조

### Pure Function으로 검증 로직 분리
```typescript
// 테스트하기 쉬운 순수 함수
describe('validateAmount', () => {
  test('양수가 아닌 경우 에러 반환', () => {
    expect(validateAmount(0)).toBe('금액은 0보다 큰 값이어야 합니다.');
    expect(validateAmount(-100)).toBe('금액은 0보다 큰 값이어야 합니다.');
  });
  
  test('정상 금액인 경우 null 반환', () => {
    expect(validateAmount(1000)).toBe(null);
  });
});
```

### 컴포넌트 테스트
```typescript
// 순수 UI 컴포넌트 테스트
test('에러가 있을 때 에러 메시지 표시', () => {
  render(
    <ExpenseForm
      formData={mockData}
      errors={{ amount: '금액을 입력하세요' }}
      onAmountChange={jest.fn()}
      // ...
    />
  );
  
  expect(screen.getByText('금액을 입력하세요')).toBeInTheDocument();
});
```

## 🚀 실제 적용 결과

### Before (단순한 폼)
```typescript
// 모든 것이 한 곳에 섞여있음
const ExpenseForm = () => {
  const [amount, setAmount] = useState(0);
  const [category, setCategory] = useState('');
  // ... 20개의 useState
  
  const handleSubmit = () => {
    // 100줄의 검증 + 저장 로직
  };
  
  return (
    // 200줄의 JSX
  );
};
```

### After (패턴 적용 후)
```typescript
// 각각 명확한 역할
const ExpenseForm = (props) => {
  // 순수 UI만 30줄
};

const ExpenseFormContainer = () => {
  // 비즈니스 로직만 50줄
};

const expenseValidators = {
  // 검증 로직만 40줄
};
```

## 📊 개선 효과

### 개발 생산성
- **코드 재사용성**: UI 컴포넌트를 다른 곳에서도 활용 가능
- **테스트 용이성**: 각 부분을 독립적으로 테스트 가능
- **유지보수성**: 변경이 필요한 부분만 수정 가능

### 사용자 경험
- **실시간 피드백**: 입력과 동시에 검증 결과 확인
- **명확한 에러 메시지**: 어떤 부분을 수정해야 하는지 명확
- **부드러운 인터렉션**: 로딩 상태, 성공/실패 피드백

## 🎯 핵심 포인트

1. **관심사 분리**: UI, 비즈니스 로직, 검증 로직을 명확히 분리
2. **상태 구조화**: 복잡한 상태는 useReducer로 체계적 관리
3. **실시간 피드백**: 사용자 경험을 위한 즉시 검증
4. **재사용성 고려**: 다른 곳에서도 활용 가능한 구조로 설계

이런 패턴들을 적용하면, 복잡한 폼도 체계적으로 관리할 수 있고, 사용자에게는 더 좋은 경험을 제공할 수 있습니다! 🎉